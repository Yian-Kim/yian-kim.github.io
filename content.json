{"pages":[{"title":"About","text":"","link":"/About/index.html"}],"posts":[{"title":"알고리즘 | 너비 우선 탐색 (BFS Searching)","text":"Algorithm : BFS Searching (너비 우선 탐색) 너비 우선 탐색(BFS Searching, Breadth First Search)은 맹목적 탐색방법의 하나로 시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법입니다. 예시문제 숫자가 있는 원은 정점(Vertex)라고 하고, 정점과 정점을 잇는 연결선을 간선(Edge)이라고 한다. 정점의 최대 개수는 30개이다. 정점과 정점의 연결관계가 인접행렬로 주어졌을 때, BFS를 이용하여 시작 정점으로부터 모든 정점을 탐색한 결과를 순서대로 화면에 출력하시오. 입력 출력 1 //test case 개수 8 1 // 정점의 개수, 시작 정점 1 2 // 정점 간 연결 관계. 1과 2가 연결 1 3 2 4 2 5 4 8 5 8 3 6 3 7 6 8 7 8 -1 -1 // 입력 끝 #1 1 2 3 4 5 6 7 8 // 방문한 정점 순서 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner; class Solution { static final int MAX_VERTEX = 30; static int num; static int map[][]; static int visit[]; static int queue[]; static int rear, front; static void breadthFirstSearch(int vertex) { visit[vertex] = 1; System.out.print(vertex + \" \"); queue[rear++] = vertex; while (front &lt; rear) { vertex = queue[front++]; for (int i = 1; i &lt;= num; i++) { if (map[vertex][i] == 1 &amp;&amp; visit[i] == 0) { visit[i] = 1; System.out.printf(\"%d \", i); queue[rear++] = i; } } } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { map = new int[MAX_VERTEX][MAX_VERTEX]; visit = new int[MAX_VERTEX]; queue = new int[MAX_VERTEX]; num = sc.nextInt(); int start = sc.nextInt(); while (true) { int v1 = sc.nextInt(); int v2 = sc.nextInt(); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } System.out.printf(\"#%d \", test_case); breadthFirstSearch(start); System.out.printf(\"\\n\"); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt; #define MAX_VERTEX 30 int num;int map[MAX_VERTEX][MAX_VERTEX];int visit[MAX_VERTEX];int queue[MAX_VERTEX];int rear, front; void breadthFirstSearch(int vertex){ int i; visit[vertex] = 1; printf(\"%d \", vertex); queue[rear++] = vertex; while (front &lt; rear) { vertex = queue[front++]; for (i = 1; i &lt;= num; i++) { if (map[vertex][i] == 1 &amp;&amp; !visit[i]) { visit[i] = 1; printf(\"%d \", i); queue[rear++] = i; } } }} int main(void){ int T; int test_case; int i,j; int start; int v1; int v2; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { for (i = 0; i &lt; MAX_VERTEX; i++) { for (j = 0; j &lt; MAX_VERTEX; j++) { map[i][j] = 0; } visit[i] = 0; queue[i] = 0; } front = 0; rear = 0; scanf(\"%d %d\", &amp;num, &amp;start); while (true) { scanf(\"%d %d\", &amp;v1, &amp;v2); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } printf(\"#%d \", test_case); breadthFirstSearch(start); printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/02/Algorithm-BFS-Searching/"},{"title":"알고리즘 | 계수 정렬 (Counting Sort)","text":"Algorithm : Counting Sort(계수 정렬) 계수 정렬(Counting sort)는 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하면서 정렬하는 알고리즘입니다. 예시문제 주어진 정수들을 Counting Sort를 이용하여 정렬하고 오름차순으로 출력하라. (주어진 정수들은 중복가능) 입력 출력 2 // # of test case 10 // # of data set 0 2 9 4 5 1 0 7 3 9 5 4 9 5 1 3 #1 0 0 1 2 3 4 5 7 9 9 #2 1 3 4 5 9 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Scanner; class Solution { static final int MAX_N = 100; static final int MAX_DIGIT = 10; static int N; // # of data set static int arr[]; static int cnt[] = new int[MAX_DIGIT]; static int sortedArr[]; static void calculateDigitNumber() { for (int i = 0; i &lt; N; i++) { cnt[arr[i]]++; } for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = cnt[i-1] + cnt[i]; } } static void executeCountingSort() { for (int i = N-1; i &gt;= 0; i--) { sortedArr[--cnt[arr[i]]] = arr[i]; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { N = sc.nextInt(); arr = new int[N]; sortedArr = new int[N]; for (int i = 0; i &lt; N; i++) { arr[i] = sc.nextInt(); } // initialize for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = 0; } calculateDigitNumber(); executeCountingSort(); //print the sorted digits System.out.print(\"#\" + test_case + \" \"); for (int i = 0; i &lt; N; i++) { System.out.print(sortedArr[i] + \" \"); } System.out.println(); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt; #define MAX_N 100#define MAX_DIGIT 10 int N; // # of data setint arr[MAX_N];int cnt[MAX_DIGIT];int sortedArr[MAX_N]; void calculateDigitNumber(){ for (int i = 0; i &lt; N; i++) { cnt[arr[i]]++; } for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = cnt[i-1] + cnt[i]; }} void executeCountingSort(){ for (int i = N-1; i &gt;= 0; i--) { sortedArr[--cnt[arr[i]]] = arr[i]; }} int main(void){ int T; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;arr[i]); } // initialize for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = 0; } calculateDigitNumber(); executeCountingSort(); //print the sorted digits printf(\"#%d \", test_case); for (int i = 0; i &lt; N; i++) { printf(\"%d \", sortedArr[i]); } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/30/Algorithm-Counting-Sort/"},{"title":"알고리즘 | 이진 탐색 (Binary Search)","text":"Algorithm : Binary Search(이진 탐색) 이진 탐색 알고리즘(Binary search algorithm)은 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘입니다. 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택하고 있습니다. 만약 처음 선택한 중앙값이 찾는 값보다 크면 그 값은 새로운 최고값이 되고, 작으면 그 값은 새로운 최하값이 됩니다. 예시문제 정렬된 정수배열에서 Binary Search를 이용하여 제시된 숫자들을 찾아라. 있으면 해당 인덱스를 출력하고, 없으면 -1 를 출력하라. (2 ≤ M ≤ 100) 입력 출력 2 // # of test case T 12 // # of element in array M 5 // # of numbers to search N 3 7 28 29 43 49 55 58 69 77 79 99 // sorted integer array 8 49 58 44 7 // numbers to search 7 3 3 4 5 6 7 8 9 1 2 3 #1 -1 5 7 -1 1 #2 -1 -1 0 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.Scanner; class Solution { static final int MAX_M = 100; static int T; // # of test case static int M; // # of element in array static int N; // # of numbers to search static int arr[]; static void binarySearch(int[] arr, int low, int high, int target) { int mid; if (low &gt; high) { System.out.print(\"-1 \"); return; } mid = (low + high) / 2; if (target &lt; arr[mid]) { binarySearch(arr, low, mid - 1, target); } else if (arr[mid] &lt; target) { binarySearch(arr, mid + 1, high, target); } else { System.out.print(mid + \" \"); return; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { System.out.print(\"#\" + test_case + \" \"); M = sc.nextInt(); N = sc.nextInt(); arr = new int[M]; for (int i = 0; i &lt; M; i++) { arr[i] = sc.nextInt(); } for (int i = 0; i &lt; N; i++) { int targetValue = sc.nextInt(); binarySearch(arr, 0, M-1, targetValue); } System.out.println(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt; #define MAX_M 100 int T; // # of test caseint M; // # of element in arrayint N; // # of numbers to searchint arr[MAX_M]; void binarySearch(int* arr, int low, int high, int target){ int mid; if (low &gt; high) { printf(\"-1 \"); return; } mid = (low + high) / 2; if (target &lt; arr[mid]) { binarySearch(arr, low, mid - 1, target); } else if (arr[mid] &lt; target) { binarySearch(arr, mid + 1, high, target); } else { printf(\"%d \", mid); return; }} int main(void){ int targetValue; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { printf(\"#%d \", test_case); scanf(\"%d %d\", &amp;M, &amp;N); for (int i = 0; i &lt; M; i++) { scanf(\"%d\", &amp;arr[i]); } for (int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;targetValue); binarySearch(arr, 0, M-1, targetValue); } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/31/Algorithm-Binary-Search/"},{"title":"알고리즘 | 깊이 우선 탐색 (DFS Searching)","text":"Algorithm : DFS Searching (깊이 우선 탐색) 깊이 우선 탐색(DFS Searching, Depth First Searching)은 맹목적 탐색방법의 하나로 한 노드를 시작으로 인접한 다른 노드를 재귀적으로 탐색해가고 끝까지 탐색하면 다시 위로 와서 다음을 탐색하여 검색합니다. 예시문제 숫자가 있는 원은 정점(Vertex)라고 하고, 정점과 정점을 잇는 연결선을 간선(Edge)이라고 한다. 정점의 최대 개수는 30개이다. 정점과 정점의 연결관계가 인접행렬로 주어졌을 때, DFS를 이용하여 시작 정점으로부터 모든 정점을 탐색한 결과를 순서대로 화면에 출력하시오. 입력 출력 1 //test case 개수 8 1 // 정점의 개수, 시작 정점 1 2 // 정점 간 연결 관계. 1과 2가 연결 1 3 2 4 2 5 4 8 5 8 3 6 3 7 6 8 7 8 -1 -1 // 입력 끝 #1 1 2 4 8 5 6 3 7 // 방문한 정점 순서 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Scanner; class Solution { static final int MAX_VERTEX = 30; static int vertex; static int map[][] = new int[MAX_VERTEX][MAX_VERTEX]; static int visit[] = new int[MAX_VERTEX]; static void depthFirstSearch(int v) { visit[v] = 1; for (int i = 1; i &lt;= vertex; i++) { if (map[v][i] == 1 &amp;&amp; visit[i] == 0) { System.out.printf(\"%d \", i); depthFirstSearch(i); } } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { vertex = sc.nextInt(); int start = sc.nextInt(); map = new int[MAX_VERTEX][MAX_VERTEX]; visit = new int[MAX_VERTEX]; while (true) { int v1 = sc.nextInt(); int v2 = sc.nextInt(); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } System.out.printf(\"#%d \", test_case); System.out.printf(\"%d \", start); depthFirstSearch(start); System.out.printf(\"\\n\"); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt; #define MAX_VERTEX 30 int vertex;int map[MAX_VERTEX][MAX_VERTEX];int visit[MAX_VERTEX]; void depthFirstSearch(int v){ int i; visit[v] = 1; for (i = 1; i &lt;= vertex; i++) { if (map[v][i] == 1 &amp;&amp; !visit[i]) { printf(\"%d \", i); depthFirstSearch(i); } }} int main(void){ int T; int test_case; int i,j; int start; int v1; int v2; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { for (i = 0; i &lt; MAX_VERTEX; i++) { for (j = 0; j &lt; MAX_VERTEX; j++) { map[i][j] = 0; } visit[i] = 0; } scanf(\"%d %d\", &amp;vertex, &amp;start); while (true) { scanf(\"%d %d\", &amp;v1, &amp;v2); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } printf(\"#%d \", test_case); printf(\"%d \", start); depthFirstSearch(start); printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/01/Algorithm-DFS-Searching/"},{"title":"알고리즘 | 다익스트라 (Dijkstra)","text":"Algorithm : Dijkstra (다익스트라) 다익스트라 알고리즘(Dijkstra)은 어떤 변도 음수 가중치를 갖지 않는 유향 그래프에서 주어진 출발점과 도착점 사이의 최단 경로 문제를 푸는 알고리즘입니다. 예시문제 방향이 있는 그래프에서 꼭지점들을 연결하는 비용이 할당 되었을 때 임의의 꼭지점에서 다른 꼭지점으로 가는 경로들 중에서 비용이 가장 적게 드는 경로, 즉 두 정점 사이의 최단 경로를 찾아라. 입력 값 첫번째 라인에는 전체 테스트 케이스의 개수가 입력된다. 두번째 라인에는 정점의 개수, 그리고 시작 정점, 도착 정점이 입력된다. 이때, 정점의 최대 개수는 100이다. 세번째 라인에는 정점을 잇는 간선 개수(m)가 입력된다. 네번째 라인부터는 연결 된 정점 값 2개와 간선에 할당 된 비용이 m번 들어온다. 이때 간선 방향은 첫번째 입력된 정점에서 두번째 입력된 정점으로 가는 방향이다. 입력 출력 1 // test case 개수 7 1 7 // 정점의 개수, 그리고 시작 정점, 도착 정점 9 // 간선 개수 1 2 4 // 1-&gt;2, 비용은 4 1 3 2 2 4 1 2 5 2 3 4 7 3 6 3 4 7 3 5 7 1 6 7 5 #1 7 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.Scanner; class Solution{ static final int N = 100; static final int INF = 100000; static int[][] map = new int[N+1][N+1]; static boolean[] visit = new boolean[N+1]; static int[] dist = new int[N+1]; static int vertex; static int edge; static int start; static int end; public static void dijkstra() { int v = 0; dist[start] = 0; for (int i = 1; i &lt;= vertex; i++) { int min = INF; for (int j = 1; j &lt;= vertex; j++) { if (visit[j] == false &amp;&amp; min &gt; dist[j]) { min = dist[j]; v = j; } } visit[v] = true; for (int j = 1; j &lt;= vertex; j++) { if (dist[j] &gt; dist[v] + map[v][j]) { dist[j] = dist[v] + map[v][j]; } } } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { vertex = sc.nextInt(); start = sc.nextInt(); end = sc.nextInt(); edge = sc.nextInt(); for (int i = 1; i &lt;= vertex; i++) { for (int j = 1; j &lt;= vertex; j++) { if (i != j) { map[i][j] = INF; } } } for (int i = 1; i &lt;= edge; i++) { int from = sc.nextInt(); int to = sc.nextInt(); int value = sc.nextInt(); map[from][to] = value; } for (int i = 1; i &lt;= vertex; i++) { dist[i] = INF; visit[i] = false; } dijkstra(); System.out.printf(\"#%d %d\\n\", test_case, dist[end]); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt; #define N 100#define INF 100000 int map[N + 1][N + 1];int visit[N + 1];int dist[N + 1];int vertex;int edge;int start;int end; void dijkstra(void){ int i; int j; int min; int v; dist[start] = 0; for (i = 1; i &lt;= vertex; i++) { min = INF; for (j = 1; j &lt;= vertex; j++) { if (visit[j] == 0 &amp;&amp; min &gt; dist[j]) { min = dist[j]; v = j; } } visit[v] = 1; for (j = 1; j &lt;= vertex; j++) { if (dist[j] &gt; dist[v] + map[v][j]) { dist[j] = dist[v] + map[v][j]; } } }} int main(void){ int test_case; int T; int i; int j; int from; int to; int value; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d %d %d\", &amp;vertex, &amp;start, &amp;end); scanf(\"%d\", &amp;edge); for (i = 1; i &lt;= vertex; i++) { for (j = 1; j &lt;= vertex; j++) { if (i != j) { map[i][j] = INF; } } } for (i = 1; i &lt;= edge; i++) { scanf(\"%d %d %d\", &amp;from, &amp;to, &amp;value); map[from][to] = value; } for (i = 1; i &lt;= vertex; i++) { dist[i] = INF; visit[i] = 0; } printf(\"#%d \", test_case); dijkstra(); printf(\"%d \\n\", dist[end]); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/07/Algorithm-Dijkstra/"},{"title":"알고리즘 | 매개변수 탐색 (Parametric Search)","text":"Algorithm : Parametric Search (매개변수 탐색) 매개변수 탐색(Parametric Search)은 어떤 알고리즘으로 해를 바로 구해내는 것이 아니고, 임의의 값을 던지고 맞는지 확인해가며 해를 구하는 방법입니다. 예시문제 길이가 각각 다른 K개의 리본을 가지고 있다. 공예작품을 만들기 위해 가지고 있는 리본을 잘라서 길이가 동일한 N개의 리본재료를 만들려고 한다. 리본재료의 최대 길이를 구하시오. ( 1 &lt;= K &lt;= 10,000; 1 &lt;= N &lt;= 1,000,000; K &lt;= N ) 손실되는 길이는 없음 만들 수 없는 경우는 없다 이미 자른 리본은 붙일 수 없다 자를 때는 정수 cm 단위로 자른다 입력 출력 1 // test case 개수 4 // 가지고 있는 리본의 개수 K 11 // 필요한 리본재료의 개수 N 802 743 457 539 #1 200 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner; class Solution { static int K; static int N; static int low, high, mid, numRibbonTape, max; static int sizeRibbonTape[]; static void search() { mid = low + (high - low) / 2; numRibbonTape = 0; for (int i = 0; i &lt; K ; i++) { numRibbonTape += (sizeRibbonTape[i] / mid); } if (numRibbonTape &gt;= N) { low = mid + 1; if (max &lt; mid) max = mid; } else { high = mid - 1; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { low = 1; high = 0 ; max = -1; K = sc.nextInt(); N = sc.nextInt(); sizeRibbonTape = new int[K]; for (int i = 0; i &lt; K; i++) { sizeRibbonTape[i] = sc.nextInt(); if ( high &lt; sizeRibbonTape[i] ) { high = sizeRibbonTape[i] ; } } while (low &lt;= high) { search(); } System.out.println(\"#\" + test_case + \" \" + max); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt; #define MAX_RIBBON 100 int K;int N;int low, high, mid, numRibbonTape, max;int sizeRibbonTape[MAX_RIBBON]; void search(){ mid = low + (high - low) / 2; numRibbonTape = 0; for (int i = 0; i &lt; K ; i++) { numRibbonTape += (sizeRibbonTape[i] / mid); } if (numRibbonTape &gt;= N) { low = mid + 1; if (max &lt; mid) max = mid; } else { high = mid - 1; }} int main(int argc, char** argv){ int T; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { low = 1; high = 0 ; max = -1; scanf(\"%d %d\", &amp;K, &amp;N); for (int i = 0; i &lt; K; i++) { scanf(\"%d\", &amp;sizeRibbonTape[i]); if ( high &lt; sizeRibbonTape[i] ) { high = sizeRibbonTape[i] ; } } while (low &lt;= high) { search(); } printf(\"#%d \", test_case); printf(\"%d\\n\", max); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/03/Algorithm-Parametric-Search/"},{"title":"알고리즘 | 동적 계획법 (Dynamic Programming)","text":"Algorithm : Dynamic Programming (동적 계획법) 동적 계획법(Dynamic programming)은 복잡한 문제를 풀기위해서 간단한 여러 개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 목적에 도달하는 방법입니다. 예시문제 상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다. 상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다. 입력 출력 2 5 50 10 100 20 40 30 50 70 10 60 7 10 30 10 50 100 20 40 20 40 30 50 60 20 80 #1 260 #2 290 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Scanner; class Solution { static int N; static int dp[][]; static int board[][]; static int max(int a, int b) { return (a&lt;b) ? b : a; } static void findSticker() { dp[0][0] = board[0][0]; dp[1][0] = board[1][0]; dp[0][1] = dp[1][0] + board[0][1]; dp[1][1] = dp[0][0] + board[1][1]; for (int i = 2; i &lt; N; i++) { dp[0][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[0][i] = max(dp[1][i - 1], dp[0][i]); dp[0][i] += board[0][i]; dp[1][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[1][i] = max(dp[0][i - 1], dp[1][i]); dp[1][i] += board[1][i]; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { N = sc.nextInt(); board = new int[2][N]; dp = new int[2][N]; for (int j = 0; j &lt; 2; j++) { for (int i = 0; i &lt; N; i++) { board[j][i] = sc.nextInt(); } } findSticker(); System.out.println(\"#\" + test_case + \" \" + max(dp[0][N - 1], dp[1][N - 1])); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt; int N;int dp[2][100001];int board[2][100001]; const int max(const int a, const int b) { return (a&lt;b) ? b : a;} void findSticker() { dp[0][0] = board[0][0]; dp[1][0] = board[1][0]; dp[0][1] = dp[1][0] + board[0][1]; dp[1][1] = dp[0][0] + board[1][1]; for (int i = 2; i &lt; N; i++) { dp[0][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[0][i] = max(dp[1][i - 1], dp[0][i]); dp[0][i] += board[0][i]; dp[1][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[1][i] = max(dp[0][i - 1], dp[1][i]); dp[1][i] += board[1][i]; }} int main() { int T; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { printf(\"#%d \", test_case); scanf(\"%d\", &amp;N); for (int j = 0; j &lt; 2; j++) { for (int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;board[j][i]); } } findSticker(); printf(\"%d\\n\", max(dp[0][N - 1], dp[1][N - 1])); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/04/Algorithm-Dynamic-Programming/"},{"title":"알고리즘 | 삽입 정렬 (Insertion Sort)","text":"Algorithm : Insertion Sort(삽입 정렬) 삽입 정렬(Insertion Sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘입니다. 예시문제 주어진 데이터를 Insertion Sort를 사용하여 정렬 하시오. 데이터의 최대 크기는 100이다. 입력 출력 1 // 전체 Test case 수 5 // 데이터 크기 1 4 5 2 3 #1 1 2 3 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Scanner; class Solution { static int input[]; static int num; static void insertionSort() { for (int i = 1; i &lt; num; i++) { int temp = input[i]; int j = i - 1; while ((j &gt;= 0) &amp;&amp; (temp &lt; input[j])) { input[j + 1] = input[j]; j = j - 1; } input[j + 1] = temp; } } static void printResult() { int i; for (i = 0; i &lt; num; ++i) { System.out.print(input[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { num = sc.nextInt(); input = new int[num]; for (int i = 0; i &lt; num; i++) { input[i] = sc.nextInt(); } insertionSort(); System.out.print(\"#\" + test_case + \" \"); printResult(); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt; #define MAX_NUM 100 int input[MAX_NUM];int num; void insertionSort(void){ int temp; int i; int j; for (i = 1; i &lt; num; i++) { temp = input[i]; j = i - 1; while ((j &gt;= 0) &amp;&amp; (temp &lt; input[j])) { input[j + 1] = input[j]; j = j - 1; } input[j + 1] = temp; }} void printResult(void){ int i; for (i = 0; i &lt; num; ++i) { printf(\"%d \", input[i]); } printf(\"\\n\");} int main(void){ int T; int test_case; int i; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;num); for (i = 0; i &lt; num; i++) { scanf(\"%d\", &amp;input[i]); } insertionSort(); printf(\"#%d \", test_case); printResult(); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/24/Algorithm-Insertion-Sort/"},{"title":"알고리즘 | 퀵 정렬 (Quick Sort)","text":"Algorithm : Quick Sort(퀵 정렬) 퀵 정렬(Quick Sort)은 기준키(pivot)를 기준으로 작거나 같은 값을 지닌 데이터는 앞으로, 큰 값을 지닌 데이터는 뒤로 가도록 하여 작은 값을 갖는 데이터와 큰 값을 갖는 데이터로 분리해가며 정렬하는 방법입니다. 예시문제 주어진 데이터를 Quick Sort를 사용하여 정렬하시오. 데이터의 최대 크기는 100이다. 입력 출력 1 // 전체 Test case 수 5 // 데이터 크기 1 4 5 2 3 #1 1 2 3 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Scanner; class Solution { static int input[]; static int num; static void quickSort(int first, int last) { int temp; if (first &lt; last) { int pivot = first; int i = first; int j = last; while (i &lt; j) { while (input[i] &lt;= input[pivot] &amp;&amp; i &lt; last) { i++; } while (input[j] &gt; input[pivot]) { j--; } if (i &lt; j) { temp = input[i]; input[i] = input[j]; input[j] = temp; } } temp = input[pivot]; input[pivot] = input[j]; input[j] = temp; quickSort(first, j - 1); quickSort(j + 1, last); } } static void printResult() { for (int i = 0; i &lt; num; ++i) { System.out.print(input[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { num = sc.nextInt(); input = new int[num]; for (int i = 0; i &lt; num; i++) { input[i] = sc.nextInt(); } quickSort(0, num - 1); System.out.print(\"#\" + test_case + \" \"); printResult(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt; #define MAX_NUM 100 int input[MAX_NUM];int num; void quickSort(int first, int last){ int pivot; int i; int j; int temp; if (first &lt; last) { pivot = first; i = first; j = last; while (i &lt; j) { while (input[i] &lt;= input[pivot] &amp;&amp; i &lt; last) { i++; } while (input[j] &gt; input[pivot]) { j--; } if (i &lt; j) { temp = input[i]; input[i] = input[j]; input[j] = temp; } } temp = input[pivot]; input[pivot] = input[j]; input[j] = temp; quickSort(first, j - 1); quickSort(j + 1, last); }} void printResult(void){ int i; for (i = 0; i &lt; num; ++i) { printf(\"%d \", input[i]); } printf(\"\\n\");} int main(void){ int T; int test_case; int i; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;num); for (i = 0; i &lt; num; i++) { scanf(\"%d\", &amp;input[i]); } quickSort(0, num - 1); printf(\"#%d \", test_case); printResult(); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/29/Algorithm-Quick-Sort/"},{"title":"알고리즘 | 순열 조합 (Permutation & Combination)","text":"Algorithm : Permutation &amp; Combination (순열 조합) 순열(Permutation)은 순서가 부여된 임의의 집합을 다른 순서로 뒤섞는 연산이며, 조합(Combination)은 집합에서 일부 원소를 취해 부분 집합을 만드는 방법을 말합니다. 예시문제 주어진 문자열 str (길이 n)에 대해 아래 두 가지를 차례로 출력하시오. 1. str의 n개 character를 일렬로 배열하는 모든 경우를 출력하시오. 2. str의 n개 character 중 k개를 취하는 모든 경우를 출력하시오. (제한사항: 주어진 string에 동일한 알파벳이 중복으로 포함되지 않음. String의 maximum size는 10. k &lt;= n.) 입력 출력 1 // # of test case ABCD 3 // n 2 // k #1 ABC ACB BAC BCA CBA CAB AB AC BC Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.Scanner; class Solution{ static final int MAX_STRING_LENGTH = 10; static int stackTop = 0; static char[] combinationStack = new char[MAX_STRING_LENGTH]; static void printCString(char[] str) { for (int i = 0; i &lt; str.length &amp;&amp; str[i] != 0; i++) { System.out.print(str[i]); } System.out.print(\"\\n\"); } static void swap(char[] str, int x, int y) { char temp = str[x]; str[x] = str[y]; str[y] = temp; } static void permutation(char[] str, int l, int r) { if (l == r) { printCString(str); } else { for (int i = l; i &lt;= r; i++) { swap(str, l, i); permutation(str, l+1, r); swap(str, l, i); //backtrack } } } static void push(char ch) { combinationStack[stackTop++] = ch; combinationStack[stackTop] = '\\0'; } static void pop() { combinationStack[--stackTop] = '\\0'; } static void combination(char[] str, int length, int offset, int k) { if (k == 0) { printCString(combinationStack); return; } for (int i = offset; i &lt;= length - k; ++i) { push(str[i]); combination(str, length, i+1, k-1); pop(); } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { String input = sc.next(); int N = sc.nextInt(); int K = sc.nextInt(); char[] str = input.toCharArray(); System.out.printf(\"#%d\\n\", test_case); str[N] = 0; permutation(str, 0, N-1); combination(str, N, 0, K); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt; #define MAX_STRING_LENGTH 10 int stackTop = 0;char combinationStack[MAX_STRING_LENGTH]; void swap(char *x, char *y){ char temp; temp = *x; *x = *y; *y = temp;} void permutation(char *str, int l, int r){ if (l == r) { printf(\"%s\\n\", str); } else { for (int i = l; i &lt;= r; i++) { swap((str+l), (str+i)); permutation(str, l+1, r); swap((str+l), (str+i)); //backtrack } }} void push(char ch) { combinationStack[stackTop++] = ch; combinationStack[stackTop] = '\\0';} void pop() { combinationStack[--stackTop] = '\\0';} void combination(const char* str, int length, int offset, int k) { if (k == 0) { printf(\"%s\\n\", combinationStack); return; } for (int i = offset; i &lt;= length - k; ++i) { push(str[i]); combination(str, length, i+1, k-1); pop(); }} int main(){ int N, K, T; char str[MAX_STRING_LENGTH]; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%s%d%d\", str, &amp;N, &amp;K); str[N] = 0; printf(\"#%d\\n\", test_case); permutation(str, 0, N-1); combination(str, N, 0, K); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/05/Algorithm-Permutation-and-Combination/"},{"title":"자료구조 | 그래프 (Graph)","text":"Data Structure : Graph(그래프) 그래프(Graph)는 컴퓨터 시스템에서 연결되어 있는 객체간의 관계를 표현할 수 있는 자료구조입니다. 예시문제 첫째 줄에는 V와 E의 갯수, 정점의 정보를 묻는 쿼리의 갯수가 주어지고 둘째 줄부터 간선의 정보(연결된 정점의 번호쌍)가 주어진다. 그 다음 줄에는 정점의 인접정점들이 무엇인지 묻는 쿼리가 정점번호로 주어진다. 정점의 번호는 0~V-1까지 이며, 간선정보는 오름차순으로 나열되어 주어진다. 또한 중복 간선은 존재하지 않는다. 입력으로 주어지는 쿼리의 정점에 인접한 정점들을 각 줄에 출력하라. (2&lt;=V&lt;=100, 1&lt;=E&lt;=1000) 입력 출력 2 6 7 3 // 정점갯수, 간선갯수 쿼리(질문)갯수 0 1 // 간선정보 0 - 1 0 2 0 3 1 2 1 4 3 4 4 5 0 // 쿼리(질문): 정점 번호 2 4 9 10 3 0 1 0 2 0 6 1 3 1 4 1 7 2 4 4 5 6 7 7 8 0 1 7 #1 1 2 3 // 정점0에 인접한 정점리스트 0 1 // 정점2에 인접한 정점리스트 1 3 5 // 정점4에 인접한 정점리스트 #2 1 2 6 0 3 4 7 1 6 8 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.Scanner; class Graph{ class AdjlistNode { int vertex; AdjlistNode next; public AdjlistNode(int v) { vertex = v; next = null; } } class AdjList { int num_members; AdjlistNode head; AdjlistNode tail; public AdjList() { num_members = 0; head = tail = null; } } int num_vertices; AdjList []adjListArr; public Graph(int n) { num_vertices = n; adjListArr = new AdjList[n]; for (int i = 0; i &lt; n; i++) { adjListArr[i] = new AdjList(); } } void addEdge(int src, int dest) { AdjlistNode newNode = new AdjlistNode(dest); if (adjListArr[src].tail != null) { adjListArr[src].tail.next = newNode; adjListArr[src].tail = newNode; } else { adjListArr[src].head = adjListArr[src].tail = newNode; } adjListArr[src].num_members++; newNode = new AdjlistNode(src); if (adjListArr[dest].tail != null) { adjListArr[dest].tail.next = newNode; adjListArr[dest].tail = newNode; } else { adjListArr[dest].head = adjListArr[dest].tail = newNode; } adjListArr[dest].num_members++; } void display(int i) { AdjlistNode adjList = adjListArr[i].head; while (adjList != null) { System.out.printf(\"%d \", adjList.vertex); adjList = adjList.next; } System.out.printf(\"\\n\"); }} class Solution{ public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int V = sc.nextInt(); int E = sc.nextInt(); int Q = sc.nextInt(); Graph graph = new Graph(V); for (int i = 0; i &lt; E; i++) { int sv = sc.nextInt(); int ev = sc.nextInt(); graph.addEdge(sv, ev); } System.out.printf(\"#%d\\n\", test_case); for (int i = 0; i &lt; Q; i++) { int sv = sc.nextInt(); graph.display(sv); } } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;stdio.h&gt;#include &lt;malloc.h&gt; typedef struct adjlistNode{ int vertex; adjlistNode *next;} AdjlistNode; typedef struct{ int num_members; AdjlistNode *head; AdjlistNode *tail;} AdjList; typedef struct{ int num_vertices; AdjList * adjListArr;} Graph; AdjlistNode * createNode(int v){ AdjlistNode * newNode = (AdjlistNode *)malloc(sizeof(AdjlistNode)); newNode-&gt;vertex = v; newNode-&gt;next = NULL; return newNode;} Graph * createGraph(int n){ Graph * graph = (Graph *)malloc(sizeof(Graph)); graph-&gt;num_vertices = n; graph-&gt;adjListArr = (AdjList *)malloc(n * sizeof(AdjList)); for (int i = 0; i &lt; n; i++) { graph-&gt;adjListArr[i].head = graph-&gt;adjListArr[i].tail = NULL; graph-&gt;adjListArr[i].num_members = 0; } return graph;} void destroyGraph(Graph * graph){ if (graph) { if (graph-&gt;adjListArr) { for (int v = 0; v &lt; graph-&gt;num_vertices; v++) { AdjlistNode * adjListPtr = graph-&gt;adjListArr[v].head; while (adjListPtr) { AdjlistNode * tmp = adjListPtr; adjListPtr = adjListPtr-&gt;next; free(tmp); } } free(graph-&gt;adjListArr); } free(graph); }} void addEdge(Graph *graph, int src, int dest){ AdjlistNode * newNode = createNode(dest); if (graph-&gt;adjListArr[src].tail != NULL) { graph-&gt;adjListArr[src].tail-&gt;next = newNode; graph-&gt;adjListArr[src].tail = newNode; } else { graph-&gt;adjListArr[src].head = graph-&gt;adjListArr[src].tail = newNode; } graph-&gt;adjListArr[src].num_members++; newNode = createNode(src); if (graph-&gt;adjListArr[dest].tail != NULL) { graph-&gt;adjListArr[dest].tail-&gt;next = newNode; graph-&gt;adjListArr[dest].tail = newNode; } else { graph-&gt;adjListArr[dest].head = graph-&gt;adjListArr[dest].tail = newNode; } graph-&gt;adjListArr[dest].num_members++;} void displayGraph(Graph * graph, int i){ AdjlistNode * adjListPtr = graph-&gt;adjListArr[i].head; while (adjListPtr) { printf(\"%d \", adjListPtr-&gt;vertex); adjListPtr = adjListPtr-&gt;next; } printf(\"\\n\");} int main(int argc, char* argv[]){ int T, V, E, Q, sv, ev; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d %d %d\", &amp;V, &amp;E, &amp;Q); Graph * graph = createGraph(V); for (int i = 0; i &lt; E; i++) { scanf(\"%d %d\", &amp;sv, &amp;ev); addEdge(graph, sv, ev); } printf(\"#%d\\n\", test_case); for (int i = 0; i &lt; Q; i++) { scanf(\"%d\", &amp;sv); displayGraph(graph, sv); } } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/27/Data-Structure-Graph/"},{"title":"자료구조 | 해시 (Hash)","text":"Data Structure : Hash(해시) 해시 테이블(Hash table)은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추가에 사용되는 자료 구조입니다. 해시 테이블은 해시 함수를 사용하여 색인(index, Key)을 버킷(bucket)이나 슬롯(slot)의 배열로 계산합니다. 예시문제 주어진 N개의 key, data쌍을 Hash table에 입력한 후, Q개의 key를 입력 받아 key에 해당하는 data를 각 줄에 출력하시오. (1&lt;=N, Q&lt;=4096) Key : 최대 64개의 문자열 Data : 최대 128개의 문자열 입력 출력 123123123234serf 234sdfdfgdcvb Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Scanner; class Hashtable{ class Hash { String key; String data; } int capacity; Hash tb[]; public Hashtable(int capacity){ this.capacity = capacity; tb = new Hash[capacity]; for (int i = 0; i &lt; capacity; i++){ tb[i] = new Hash(); } } private int hash(String str) { int hash = 5381; for (int i = 0; i &lt; str.length(); i++) { int c = (int)str.charAt(i); hash = ((hash &lt;&lt; 5) + hash) + c; } if (hash &lt; 0) hash *= -1; return hash % capacity; } public String find(String key){ int h = hash(key); int cnt = capacity; while(tb[h].key != null &amp;&amp; (--cnt) != 0) { if (tb[h].key.equals(key)){ return tb[h].data; } h = (h + 1) % capacity; } return null; } boolean add(String key, String data) { int h = hash(key); while(tb[h].key != null) { if (tb[h].key.equals(key)){ return false; } h = (h + 1) % capacity; } tb[h].key = key; tb[h].data = data; return true; }} class Solution{ final static int MAX_TABLE = 4096; public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { Hashtable tb = new Hashtable(MAX_TABLE); int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) { String k = sc.next(); String d = sc.next(); tb.add(k, d); } System.out.printf(\"#%d\\n\", test_case); int Q = sc.nextInt(); for (int i = 0; i &lt; Q; i++) { String k = sc.next(); String d = tb.find(k); if (d != null) { System.out.printf(\"%s\\n\", d); } else { System.out.printf(\"not find\\n\"); } } } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt; #define MAX_KEY 64#define MAX_DATA 128#define MAX_TABLE 4096 typedef struct{ char key[MAX_KEY + 1]; char data[MAX_DATA + 1];}Hash;Hash tb[MAX_TABLE]; unsigned long hash(const char *str){ unsigned long hash = 5381; int c; while (c = *str++) { hash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE; } return hash % MAX_TABLE;} int find(const char *key, char *data){ unsigned long h = hash(key); int cnt = MAX_TABLE; while (tb[h].key[0] != 0 &amp;&amp; cnt--) { if (strcmp(tb[h].key, key) == 0) { strcpy(data, tb[h].data); return 1; } h = (h + 1) % MAX_TABLE; } return 0;} int add(const char *key, char *data){ unsigned long h = hash(key); while (tb[h].key[0] != 0) { if (strcmp(tb[h].key, key) == 0) { return 0; } h = (h + 1) % MAX_TABLE; } strcpy(tb[h].key, key); strcpy(tb[h].data, data); return 1;} int main(int argc, char* argv[]){ int T, N, Q; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { memset(tb, 0, sizeof(tb)); scanf(\"%d\", &amp;N); char k[MAX_KEY + 1]; char d[MAX_DATA + 1]; for (int i = 0; i &lt; N; i++) { scanf(\"%s %s\\n\", &amp;k, &amp;d); add(k, d); } printf(\"#%d\\n\", test_case); scanf(\"%d\", &amp;Q); for (int i = 0; i &lt; Q; i++) { char k[MAX_KEY + 1]; char d[MAX_DATA + 1]; scanf(\"%s\\n\", &amp;k); if (find(k, d)) { printf(\"%s\\n\", d); } else { printf(\"not find\\n\"); } } } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/25/Data-Structure-Hash/"},{"title":"자료구조 | 연결리스트 (Linked List)","text":"Data Structure : Linked List(연결리스트) 연결리스트(Linked List)는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로, 데이터를 저장하는 자료 구조입니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 순서대로 Linked List에 넣은 후, 2개의 간격으로 하나씩 데이터를 뺄 때 마지막에 남아 있는 데이터를 출력하시오. Ex) 1 2 3 4 5 -&gt; 2 3 4 5 -&gt; 2 3 5 -&gt; 2 5 -&gt; 2 입력 출력 2 //테스트 케이스 수 5 //입력 수 1 2 3 4 5 //입력 데이터 6 1 2 3 4 5 6 #1 2 #2 5 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.Scanner; class ListNode { int data; ListNode prev; ListNode next; public ListNode() { data = 0; prev = this; next = this; } public static ListNode appendListNode(ListNode head, int data) { ListNode node = new ListNode(); node.data = data; if (head == null) { head = node; } else { ListNode last = head.prev; last.next = node; head.prev = node; node.prev = last; node.next = head; } return head; } public static ListNode removeListNode(ListNode head, ListNode node) { if (head == head.next) { return null; } else { ListNode prevNode = node.prev; ListNode nextNode = node.next; prevNode.next = nextNode; nextNode.prev = prevNode; return (head == node) ? nextNode : head; } }} class Solution{ public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { ListNode head = null; int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) { int data = sc.nextInt(); head = ListNode.appendListNode(head, data); } ListNode node = head; while(head != head.next) { ListNode nextNode = node.next; head = ListNode.removeListNode(head, node); node = nextNode.next.next; } System.out.printf(\"#%d %d\\n\", test_case, head.data); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt; #define MAX_NODE 100 typedef struct listNode{ int data; struct listNode* prev; struct listNode* next;} ListNode; typedef struct{ int use; ListNode node;} ListNodeHeap; ListNodeHeap heap[MAX_NODE]; void initHeap(void){ int i; for (i = 0; i &lt; MAX_NODE; i++) { heap[i].use = 0; }} void initListNode(ListNode* node){ node-&gt;data = 0; node-&gt;prev = node; node-&gt;next = node;} ListNode* getListNode(void){ int i; for (i = 0; i &lt; MAX_NODE; i++) { if (!heap[i].use) { heap[i].use = 1; initListNode(&amp;heap[i].node); return &amp;heap[i].node; } } return NULL;} void destroyListNode(ListNode* node){ ListNodeHeap* heap_node = (ListNodeHeap*)((int*)node - 1); heap_node-&gt;use = 0;} ListNode* appendListNode(ListNode* list, int data){ ListNode* node = getListNode(); node-&gt;data = data; if (list == NULL) { return node; } else { ListNode* last = list-&gt;prev; last-&gt;next = node; list-&gt;prev = node; node-&gt;prev = last; node-&gt;next = list; return list; }} ListNode* removeListNode(ListNode* list, ListNode* node){ if (list == list-&gt;next) { destroyListNode(node); return NULL; } else { ListNode* prev = node-&gt;prev; ListNode* next = node-&gt;next; prev-&gt;next = next; next-&gt;prev = prev; destroyListNode(node); return (list == node) ? next : list; }} int main(int argc, char* argv[]){ int T, N; setbuf(stdout, NULL); scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; ++test_case) { ListNode* list = NULL; ListNode* node; int i; initHeap(); scanf(\"%d\", &amp;N); for (i = 0; i &lt; N; i++) { int data; scanf(\"%d\", &amp;data); list = appendListNode(list, data); } node = list; while (list != list-&gt;next) { ListNode* nextNode = node-&gt;next; list = removeListNode(list, node); node = nextNode-&gt;next-&gt;next; } printf(\"#%d %d\\n\", test_case, list-&gt;data); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/28/Data-Structure-Linked-List/"},{"title":"자료구조 | 우선순위 큐 (Priority Queue)","text":"Data Structure : Priority Queue(우선순위 큐) 우선순위 큐는 높은 우선순위를 가진 원소는 낮은 우선순위를 가진 원소보다 먼저 처리되는 자료구조입니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 작은 숫자가 높은 우선순위를 갖는 Priority Queue에 저장하고, 우선 순위가 높은 숫자부터 차례대로 출력하시오.(입력에는 오류가 없다고 가정) 입력 출력 2 //테스트 케이스 수 10 //입력 수 10 49 38 17 56 92 8 1 13 55 //입력 데이터 13 4 22 50 13 5 1 22 35 21 7 99 100 14 #1 1 8 10 13 17 38 49 55 56 92 #2 1 4 5 7 13 14 21 22 22 35 50 99 100 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.Scanner; class Solution { static Scanner sc; static final int MAX_SIZE = 100; static int heap[] = new int[MAX_SIZE]; static int heapSize = 0; static void heapInit() { heapSize = 0; } static void heapPush(int value) { if (heapSize + 1 &gt; MAX_SIZE) { return; } heap[heapSize] = value; int current = heapSize; while (current &gt; 0 &amp;&amp; heap[current] &lt; heap[(current - 1) / 2]) { int temp = heap[(current - 1) / 2]; heap[(current - 1) / 2] = heap[current]; heap[current] = temp; current = (current - 1) / 2; } heapSize = heapSize + 1; } static int heapPop() { if (heapSize &lt;= 0) { return -1; } int value = heap[0]; heapSize = heapSize - 1; heap[0] = heap[heapSize]; int current = 0; while (current &lt; heapSize &amp;&amp; current * 2 + 1 &lt; heapSize) { int child; if (current * 2 + 2 &gt;= heapSize) { child = current * 2 + 1; } else { child = heap[current * 2 + 1] &lt; heap[current * 2 + 2] ? current * 2 + 1 : current * 2 + 2; } if (heap[current] &lt; heap[child]) { break; } int temp = heap[current]; heap[current] = heap[child]; heap[child] = temp; current = child; } return value; } static void heapPrint(int[] heap, int heap_size) { for (int i = 0; i &lt; heap_size; i++) { System.out.print(heap[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); heapInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); heapPush(value); } System.out.print(\"#\" + test_case + \" \"); for (int i = 0; i &lt; N; i++) { System.out.print(heapPop() + \" \"); } System.out.println(); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt; #define MAX_SIZE 100 int heap[MAX_SIZE];int heapSize = 0; void heapInit(void){ heapSize = 0;} int heapPush(int value){ if (heapSize + 1 &gt; MAX_SIZE) { printf(\"queue is full!\"); return 0; } heap[heapSize] = value; int current = heapSize; while (current &gt; 0 &amp;&amp; heap[current] &lt; heap[(current - 1) / 2]) { int temp = heap[(current - 1) / 2]; heap[(current - 1) / 2] = heap[current]; heap[current] = temp; current = (current - 1) / 2; } heapSize = heapSize + 1; return 1;} int heapPop(int *value){ if (heapSize &lt;= 0) { return -1; } *value = heap[0]; heapSize = heapSize - 1; heap[0] = heap[heapSize]; int current = 0; while (current * 2 + 1 &lt; heapSize) { int child; if (current * 2 + 2 == heapSize) { child = current * 2 + 1; } else { child = heap[current * 2 + 1] &lt; heap[current * 2 + 2] ? current * 2 + 1 : current * 2 + 2; } if (heap[current] &lt; heap[child]) { break; } int temp = heap[current]; heap[current] = heap[child]; heap[child] = temp; current = child; } return 1;} int main(int argc, char* argv[]){ int T, N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); heapInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); heapPush(value); } printf(\"#%d \", test_case); for (int i = 0; i &lt; N; i++) { int value; heapPop(&amp;value); printf(\"%d \", value); } printf(\"\\n\"); } return 0;} [참고차료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/23/Data-Structure-Priority-Queue/"},{"title":"자료구조 | 큐 (Queue)","text":"Data Structure : Queue(큐) 큐는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말합니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 순서대로 Queue에 넣은 후 하나씩 꺼내 화면에 출력하시오. 입력 출력 2 // 테스트 케이스 수 5 // 데이터 크기 1 2 3 4 5 5 5 4 2 3 1 #1 1 2 3 4 5 #2 5 4 2 3 1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Scanner; class Solution { static final int MAX_N = 100; static int front; static int rear; static int queue[] = new int[MAX_N]; static void queueInit() { front = 0; rear = 0; } static boolean queueIsEmpty() { return (front == rear); } static boolean queueIsFull() { if ((rear + 1) % MAX_N == front) { return true; } else { return false; } } static boolean queueEnqueue(int value) { if (queueIsFull()) { System.out.print(\"queue is full!\"); return false; } queue[rear] = value; rear++; if (rear == MAX_N) { rear = 0; } return true; } static Integer queueDequeue() { if (queueIsEmpty()) { System.out.print(\"queue is empty!\"); return null; } Integer value = new Integer(queue[front]); front++; if (front == MAX_N) { front = 0; } return value; } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); queueInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); queueEnqueue(value); } System.out.print(\"#\" + test_case + \" \"); while (!queueIsEmpty()) { Integer value = queueDequeue(); if (value != null) { System.out.print(value.intValue() + \" \"); } } System.out.println(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt; #define MAX_N 100 int front;int rear;int queue[MAX_N]; void queueInit(void){ front = 0; rear = 0;} int queueIsEmpty(void){ return (front == rear);} int queueIsFull(void){ if ((rear + 1) % MAX_N == front) { return 1; } else { return 0; }} int queueEnqueue(int value){ if (queueIsFull()) { printf(\"queue is full!\"); return 0; } queue[rear] = value; rear++; if (rear == MAX_N) { rear = 0; } return 1;} int queueDequeue(int *value){ if (queueIsEmpty()) { printf(\"queue is empty!\"); return 0; } *value = queue[front]; front++; if (front == MAX_N) { front = 0; } return 1;} int main(int argc, char* argv[]){ int T; int N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); queueInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); queueEnqueue(value); printf(\"setValue\"); } printf(\"#%d \", test_case); while (!queueIsEmpty()) { int value; if (queueDequeue(&amp;value) == 1) { printf(\"%d \", value); } } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/22/Data-Structure-Queue/"},{"title":"자료구조 | 스택 (Stack)","text":"Data Structure : Stack(스택) 스택은 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조(LIFO - Last In First Out)로 데이터를 저장하는 형식을 말합니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 순서대로 Stack에 넣은 후 하나씩 꺼내 화면에 출력하시오. 입력 출력 2 // 테스트 케이스 수 5 // 데이터 크기 1 2 3 4 5 5 5 4 2 3 1 #1 5 4 3 2 1 #2 1 3 2 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.Scanner; class Solution { static final int MAX_N = 100; static int top; static int stack[] = new int[MAX_N]; static void stackInit() { top = 0; } static boolean stackIsEmpty() { return (top == 0); } static boolean stackIsFull() { return (top == MAX_N); } static boolean stackPush(int value) { if (stackIsFull()) { System.out.println(\"stack overflow!\"); return false; } stack[top] = value; top++; return true; } static Integer stackPop() { if (top == 0) { System.out.println(\"stack is empty!\"); return null; } top--; Integer value = new Integer(stack[top]); return value; } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); stackInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); stackPush(value); } System.out.print(\"#\" + test_case + \" \"); while (!stackIsEmpty()) { Integer value = stackPop(); if (value != null) { System.out.print(value.intValue() + \" \"); } } System.out.println(); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt; #define MAX_N 100 int top;int stack[MAX_N]; void stackInit(void){ top = 0;} int stackIsEmpty(void){ return (top == 0);} int stackIsFull(void){ return (top == MAX_N);} int stackPush(int value){ if (stackIsFull()) { printf(\"stack overflow!\"); return 0; } stack[top] = value; top++; return 1;} int stackPop(int *value){ if (top == 0) { printf(\"stack is empty!\"); return 0; } top--; *value = stack[top]; return 1;} int main(int argc, char* argv[]){ int T, N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); stackInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); stackPush(value); } printf(\"#%d \", test_case); while (!stackIsEmpty()) { int value; if (stackPop(&amp;value) == 1) { printf(\"%d \", value); } } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/21/Data-Structure-Stack/"},{"title":"자료구조 | 트리 (Tree)","text":"Data Structure : Tree(트리) 트리 구조란 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 구조입니다. 간단하게는 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리(Tree)라고 부릅니다. 예시문제 주어진 입력 값으로 트리를 구성하고, 구성된 트리를 전위순회하고 방문한 노드의 번호를 출력하시오. 첫 줄에는 전체 테스트 케이스의 수(T), 두 번째 줄에는 노드의 총 수(nodeNum), 간선의 총 수(edgeNum)가 주어진다. 그 다음 줄에는 간선이 나열 된다. 간선은 그것을 이루는 두 정점으로 표기된다. 간선은 항상 “부모 자식” 순서로 표기 된다. 예를 들어 “1 2”는 정점 1과 2를 잇는 간선을 의미하며 1이 부모 2가 자식을 의미한다. 부모는 최대 2개의 자식 노드를 갖으며, 최대 노드의 개수는 10000개이다. 입력 출력 2 // Testcase 수 13 12 // N: 노드의 총 수, E: 간선의 총 수 1 2 1 3 2 4 3 5 3 6 4 7 7 12 5 9 5 8 6 11 6 10 11 13 // 간선 정보 (“부모 자식” 순서) 10 9 1 2 1 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 #1 1 2 4 7 12 3 5 9 8 6 11 13 10 #2 1 2 3 4 5 6 7 8 9 10 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.Scanner; class Tree { static final int MAX_CHILD_NUM = 2; class TreeNode { int parent; int []child = new int[MAX_CHILD_NUM]; public TreeNode(int parent) { this.parent = parent; for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { child[i] = -1; } } } TreeNode []treenode; int nodeNum; public Tree(int nodeNum) { this.nodeNum = nodeNum; treenode = new TreeNode[nodeNum+1]; for (int i = 0; i &lt;= nodeNum; i++) { treenode[i] = new TreeNode(-1); } } public void addChild(int parent, int child) { int found = -1; for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { if (treenode[parent].child[i] == -1) { found = i; break; } } if (found == -1) return; treenode[parent].child[found] = child; treenode[child].parent = parent; } public int getRoot() { for (int i = 1; i &lt; nodeNum; i++) { if (treenode[i].parent == -1) { return i; } } return -1; } public void preOrder(int root) { System.out.printf(\"%d \", root); for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { int child = treenode[root].child[i]; if (child != -1) { preOrder(child); } } }} class Solution { public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; ++test_case) { int node = sc.nextInt(); int edge = sc.nextInt(); Tree tree = new Tree(node); for (int i = 0; i &lt; edge; i++) { int parent = sc.nextInt(); int child = sc.nextInt(); tree.addChild(parent, child); } int root = tree.getRoot(); System.out.printf(\"#%d \", test_case); tree.preOrder(root); System.out.printf(\"\\n\"); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt; #define MAX_NODE_NUM 10000#define MAX_CHILD_NUM 2 typedef struct{ int parent; int child[MAX_CHILD_NUM];} TreeNode;TreeNode tree[MAX_NODE_NUM];int nodeNum;int edgeNum;int root; void initTree(void) { int i; int j; for (i = 0; i &lt;= nodeNum; i++) { tree[i].parent = -1; for (j = 0; j &lt; MAX_CHILD_NUM; j++) { tree[i].child[j] = -1; } }} void addChild(int parent, int child) { int i; for (i = 0; i &lt; MAX_CHILD_NUM; i++) { if (tree[parent].child[i] == -1) { break; } } tree[parent].child[i] = child; tree[child].parent = parent;} int getRoot(void) { int i; int j; for (i = 1; i &lt;= nodeNum; i++) { if (tree[i].parent == -1) { return i; } } return -1;} void preOrder(int root) { int i; int child; printf(\"%d \", root); for (i = 0; i &lt; MAX_CHILD_NUM; i++) { child = tree[root].child[i]; if (child != -1) { preOrder(child); } }} int main(void){ int test_case; int T; int i; int parent; int child; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; ++test_case) { scanf(\"%d %d\", &amp;nodeNum, &amp;edgeNum); initTree(); for (i = 0; i &lt; edgeNum; i++) { scanf(\"%d %d\", &amp;parent, &amp;child); addChild(parent, child); } root = getRoot(); printf(\"#%d \", test_case); preOrder(root); printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/26/Data-Structure-Tree/"},{"title":"[이슈해결] Java ArrayIndexOutOfBoundsException","text":"Error: java.lang.ArrayIndexOutOfBoundsException 🌰 오류메시지 1234// Error MessageException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 1 at Main.main(Main.java:12) 💎 문제상황 지원 회사의 온라인 코딩테스트에 응시하다가 에러가 발생했습니다. 해당 에러는 최근에 제가 자주 접했던 에러입니다. 아래 코드의 의도는 개행문자 단위로 한 번에 입력을 받아 처리하고, 문자열과 숫자를 따로 분리하려고 했습니다. String[] input = br.readLine().split(&quot;\\\\n&quot;);에서 java.lang.ArrayIndexOutOfBoundsException에러가 발생했고, 이를 처리하기 위해 알아보았습니다. 🧩 예시코드 12345678910111213141516// Wrong Code : Error가 발생한 Full Code입니다.import java.io.*;class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); String[] input = br.readLine().split(\"\\\\n\"); // Error int x = 0; for (int i=0; i&lt;n; i++) { String command = input[i].split(\" \")[0]; x = Integer.parseInt(input[i].split(\" \")[1]); } }} 예시 입력값] 12enqueue 1enqueue 2enqueue 2enqueue 1enqueue 2dequeuedequeuedequeuedequeuedequeueenqueue 7dequeue 🔑 해결방안 예시 입력값을 보시면 dequeue와 enqueue가 번갈아 나옵니다. String[] input에서 한 번에 입력받지 않고, for문을 사용하여 한 줄씩 입력받는 방식으로 변경하여 에러를 해결했습니다. 1234567891011121314151617// Right Code : Error를 해결한 Full Code입니다.import java.io.*;class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); // String[] input = br.readLine().split(\"\\\\n\"); // Error int x = 0; for (int i=0; i&lt;n; i++) { String input = br.readLine(); // Solving String command = input[i].split(\" \")[0]; x = Integer.parseInt(input[i].split(\" \")[1]); } }} 위의 코드에서 Error가 발생했던 입력문을 Solving 부분으로 바꿔주어 에러를 해결할 수 있었습니다. 해당 이슈에서는 ArrayIndexOutOfBoundsException 에러가 난 이유가 br.readLine()에 이미 강제개행이 포함이 되어 있어, 없는 문자에 접근하는 것으로 이해했습니다. 개행문자 단위로 입력을 받을 경우, 위의 내용처럼 입력을 받는 것이 낫다는 것을 알게 되었습니다.","link":"/Issues/2019/09/29/Issues-Java-ArrayIndexOutOfBoundsException/"},{"title":"[이슈등록] Java 배열에서 최대값 찾기 구문에러","text":"Error: The method max(Collection&lt;? extends T&gt;) in the type Collections is not applicable for the arguments (int[]) 🌰 오류메시지123456// Error MessageException in thread \"main\" java.lang.Error: Unresolved compilation problem: The method max(Collection&lt;? extends T&gt;) in the type Collections is not applicable for the arguments (int[]) at Main.main(Main.java:28) 💎 문제상황비타알고 알고리즘 문제를 풀다가 오류가 발생했습니다. C++에서 max_element 사용해서 배열 자체를 최대값을 찾는게 가능한 것 같은데 Java에서는 Math.max로 배열 비교가 안되는 것 같습니다. Java API Document에서도 찾지 못했습니다. 🧩 예시코드123// Full Code는 추후 업데이트 하도록 하겠습니다.int maxNum = Collections.max(dp); 🔑 해결방안여기서 2가지 궁금증을 가지고 이슈등록을 진행했으며, 해결되는대로 글을 업데이트하겠습니다. 우선, Arrays와 Collections에 대한 기초가 미흡하다고 느껴서 그 부분에 대해 공부를 해봐야겠네요. 1) C++에서 max_element가 Java에서 Math.max랑 같은가? 2) Java로 구현하려면 하나씩 max 일일이 비교해야 되는것인가? 해결되는대로 본문 수정하겠습니다.","link":"/Issues/2019/09/25/Issues-Java-Collection-max/"},{"title":"후기 | NHN 2019 하반기 기술부문 신입사원 공개채용 설명회","text":"지난 9월 10일, 캐치카페 한양대에서 \"NHN 2019 하반기 기술부문 신입사원 공개채용 설명회\"가 있었습니다. 1부에는 멘토링을 진행했고 2부에는 채용설명회를 진행했었는데요, Q&A에 나온 질의응답 일부분을 정리해보았습니다. 1부에는 빙 둘러서 앉아있었는데요, 1~5시 사이에 1시간 간격으로 질의응답 시간이 있었습니다. 인사담당자 한 분과 현직자 두 분과 함께 했습니다. 세 분이 번갈아가며 질의응답을 해주셨습니다. 1부 멘토링 : 질의응답 Q1. 개발자 인재상 A1. 개발자 인재상이 없는 이유는 특정지을 수 없기 때문입니다. 지원자의 성격과 특징을 봅니다. Q2. 코딩테스트는 어떻게 진행되는지? Q2. 언어는 C, C++, Java만 지원되며, 2시간동안 온라인으로 진행됩니다. Q3. Feel the TOAST 때 무엇을 하는지? A3. 오전 동안 1문제를 풀게 되며 라이브 코딩으로 진행됩니다. 오후에는 기술면접으로 손코딩을 합니다. Q4. 전산학 기초는 어떻게 공부해야 하는지? A4. 대학생 때 보던 전공책이나 수업용 PPT, 정보처리기사 등 자주 출제되는 문제 위주로 공부하면 됩니다. 학생 때 중간, 기말고사에 나왔던 문제들 위주로요. Q5. 자기소개서 쓰는 꿀팁이 있다면? A5. 자기소개서는 서류전형 때 타 기업 이름을 썼는지, 임시저장을 위해 무의미한 문자열을 입력해두었는지 등 먼저 확인하고 1번만 확인한다고 하십니다. 최종면접 때 자기소개서에서 질문이 나올 수도, 나오지 않을 수도 있습니다. (저는 타 기업과는 다르게 인사담당자님께서 참 솔직하다는 인상을 받았네요.) Q6. 어떤 개발환경, 어떤 언어를 사용하는지? A6. 팀마다 다르겠지만 서버개발은 Java, Spring을 사용하기도 하고 FE 개발은 Vue를 사용하기도 합니다. Q7. 채용인원은 어떻게 되는지? A7. 인원을 정해두지는 않습니다. 올해는 사업확장이 활발하므로 채용 규모가 작년과 비슷할 것으로 예상됩니다. Q8. SW지식 테스트는 어떤 형태로 문제가 출제되는지? A8. 객관식, 단답형, 서술형 등 다양하게 있으며, 아주 잠깐이지만 캐치에서 만든 영상에 문제가 나옵니다. 2부 채용설명회 채용설명회는 위의 사진입니다. 위 선물과 비어파티가 함께 진행되었습니다. 전 아쉽게도 개인사정으로 맥주는 못 마셨지만 ^^; 나중에 NHN에 입사한다면 노트북에 잔뜩 붙이고 싶은 귀여운 스티커들입니다. 2019년 9월 17일 오후 2시까지 지원서 마감이니 얼른 지원해야겠네요.","link":"/Review/2019/09/16/Review-NHN-2019-Technical-Division-Public-Recruitment-Session/"},{"title":"알고리즘 | 재귀(Recursion)","text":"Algorithm : Recursion(재귀) 재귀(Recursion)는 수학이나 컴퓨터 과학 등에서 자신을 정의할 때 자기 자신을 재참조하는 방법을 뜻합니다. 주로 이 방법은 함수에 적용한 재귀 함수(Recursion Function)의 형태로 많이 사용됩니다. 예시문제 주어지는 수가 1 이상 20 이하의 수일 때, 주어진 수의 Factorial 값을 구해 아래와 같이 출력하시오. 입력 출력 3 // 전체 Test case 수 9 // Test case index 12 20 #1 9! = 362880 #2 12! = 479001600 #3 20! = 2432902008176640000 Java12345678910111213141516171819202122232425262728293031323334import java.util.Scanner; class Solution { static long factorial(int num) { if (num == 0) { return 1; } else { return num * factorial(num - 1); } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; ++test_case) { int num = sc.nextInt(); long value = factorial(num); System.out.println(\"#\" + test_case + \" \" + num + \"! = \" + value); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt; long long factorial(int num){ if (num == 0) { return 1; } else { return num * factorial(num - 1); }} int main(void){ int test_case; int T; int num; long long value; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; ++test_case) { scanf(\"%d\", &amp;num); value = factorial(num); printf(\"#%d %d! = %lld\\n\", test_case, num, value); }} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/20/Algorithm-Recursion/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/Devlog/Hexo/2019/06/03/hello-world/"},{"title":"운영체제 | #01 운영체제 소개","text":"1. 운영체제 소개(1) 개요운영체제란? 컴퓨터 하드웨어와 컴퓨터 사용자 간의 매개체 역할을 하는 시스템 소프트웨어 컴퓨터 자원을 통제하고 할당하는 공통 기능을 컴퓨터웨어 소프트웨어 하나로 통합한 것 커널(Kernel) 운영체제의 핵심으로 메모리에 상주하며 운영체제의 다른 부분 또는 응용 프로그램 수행에 필요한 환경을 설정하는 소프트웨어 목적 컴퓨터 시스템을 편리하게 이용 컴퓨터 하드웨어를 효율적으로 관리 컴퓨터 자원 관리 측면에서의 운영체제의 역할 조정자 운영체제는 시스템을 운영하여 여러 운영 요소(하드웨어, 소프트웨어(프로그램), 데이터)를 적절하게 사용할 수 있도록 제어 자원 할당자 또는 관리자 컴퓨터 시스템이 문제를 해결하는 데 필요한 자원(프로세서 시간, 메모리 공간, 파일 저장 공간, 입출력장치 등)을 할당하는 업무 입출력장치와 사용자 프로그램 제어 컴퓨터 시스템의 부적절한 사용이나 오류를 방지하기 위해 사용자 프로그램의 실행의 제어 입출력장치를 동작시키고 통제하는 역할 컴퓨터 시스템 구성요소와 운영체제 (2) 운영체제의 역할과 목적운영체제의 목적 운영체제는 두 가지 주요 목적을 달성하기 위해 발전 편리성 : 사용자가 프로그램을 개발하고 사용하는 데 좀 더 편리한 환경 제공 효율성 : 자원을 효과적으로 사용하기 위해 각 프로그램을 유기적으로 결합하여 시스템 전체 성능을 향상시키는 방향으로 설계 처리능력 : 시스템의 생산성을 나타내는 대표 지표로 단위 시간당 처리하는 작업량 신뢰도 : 하드웨어(펌웨어), 소프트웨어가 실패 없이 주어진 기능을 수행할 수 있는 능력 응답시간 : 사용자가 시스템에 작업을 의뢰한 후 반응을 얻을 때까지의 시간 (시분할 방식 시스템과 온라인 시스템에서 사용하는 용어, 일괄 처리 시스템에서는 Turn Around Time) 사용가능도(가동률) : 사용자가 일정 기간 동안 컴퓨터를 실제로 사용한 시간(비율) (3) 운영체제의 유형일괄 처리 시스템(batch processing system) 유휴 상태의 시간을 없애기 위하여 작업 순서의 자동화(automatic job sequencing) 개념이 도입 상주 모니터(resident monitor)를 수행 작업의 준비 및 실행 순서를 자동화함으로써 시스템의 성능을 증진 다중 프로그래밍 시스템(multi programming system) 중앙처리장치가 항상 수행되도록 하여 그 이용도를 높이기 위한 방안 주기억장치 내에 여러 프로그램들이 존재하도록 시분할 시스템(time-sharing system) 여러 사용자들이 컴퓨터 자원에 대한 짧은 시간 단위의 공유(sharing) 사용자는 대화식(interactive) 단말장치를 이용하여 시분할 시스템과 인터페이스를 수행 실시간시스템(real-time system) 매우 엄격하게 정의되어 있는 시간 제약 등과 같은 사건들의 제시된 상황을 분석 사전에 정의된 제약 내에서 수행되어야 함 다중 처리 시스템(multiprocessing system) 밀착된 결합(tightly coupled) 시스템 혹은 강결합 시스템라고도 함 병렬 시스템(parallel system)이라고도 함 공유기억장치(common memory)를 통하여 하나로 연결된 다중 처리기(multi-processor)의 제어 및 공유를 위한 시스템 개인용 컴퓨터 시스템 중앙처리장치와 주변장치 이용률을 최대화시키려는 노력 대신에 편리성과 응답성을 더 중요시 함 분산처리 시스템(distributed processing system) 느슨한 결합(loosely coupled) 시스템이라고도 함. 프로세서들이 기억장치와 클럭을 공유하지 않으며 각 프로세서들은 자신의 지역(local) 기억장치 보유 프로세서들은 고속의 버스(bus)나 전화선과 같은 다양한 통신 라인을 통해 서로 통신 자원을 가지고 있는 사이트는 서버(server)가 되며, 반면 다른 사이트에서의 클라이언트(client)나 사용자는 그 자원을 사용 멀티미디어 시스템(multimedia system) 다양한 미디어를 이용하여 멀티미디어 콘텐츠를 제작하기 위해 필요한 하드웨어와 소프트웨어로 구성 멀티미디어 콘텐츠를 제작하기 위한 저작도구(authoring tool)가 필요 임베디드 시스템(embedded system) 정의 마이크로프로세서 또는 마이크로컨트롤러를 내장하여 시스템 제작자가 의도한 몇 가지 혹은 특수한 기능만을 수행하도록 제작된 시스템 임베디드 운영체제의 강점 임베디드 시스템과 그 한정된 자원들의 능력에 맞게 최적화 (4) 운영체제의 발전 과정운영체제의 발전 과정 운영체제와 컴퓨터 구조는 서로 많은 영향을 끼쳤으며, 관찰을 통해 운영체제의 개념을 올바르게 이해할 수 있다. 하드웨어와 같이 “세대”라고 불리는 발전 단계를 거쳤으며, 그 과정은 아래의 표와 같다. (5) 운영체제에 대한 관점자원 관리자 관점 각 자원에 대한 수행 과정 자원의 상태를 추적·저장 어떤 프로세스가 언제 어떤 자원을 얼마나 사용할 것인지를 결정하기 위한 정책 수립 자원의 할당 자원의 회수 프로세스 관리 기능 중앙처리장치와 프로세스(process)의 상태를 추적·저장 프로세스 스케줄러(process scheduler) 기억장치 관리 기능 기억장치의 상태를 추적·저장 장치(device) 관리 기능 채널 등의 제어장치 및 입출력장치와 같은 각종 장치의 상태를 추적·저장 입출력 트래픽 제어기(I/O traffic controller) 입출력 스케줄 링(I/O scheduling) 정보 관리 기능 정보의 위치, 사용 여부 및 상태 등을 추적·관리 파일시 스템(file system)이리고도 함 프로세스 관점 하나의 작업이 제시되어 완료될 때까지 하나의 프로세스에 대하여 그 상태를 변환시키고 관리 [그림1-7] 다중 프로그래밍 시스템에서의 복수 프로세스 계층 구조 관점 자원 관리 루틴이 어떻게 수행되고, 이 루틴들이 상호간에 어디에 논리적으로 위치하는가 모듈화 된 자원 관리 [그림1-8] 계층적 기계 개념의 구성도 (6) 입출력 프로그래밍대부분의 컴퓨터에 있어서 입출력은 중앙처리장치와 비동기적(asynchronous)으로 수행즉, 중앙처리장치와 입출력장치에 대한 작동이 독립적이며, 수행상의 시간관계 규정이 없이 병행적으로 수행BIOS (basic input/output system) ROM에서 얻어낸 정보 부팅된 프로세스를 실행시키는 명령어들을 포함 컴퓨터 칩에 저장된 명령어들을 펌웨어(firmware)라고 함 BIOS를 뛰어넘는 확장성 펌웨어 인터페이스(EFI: extensible firmware interface)가 개발 부트 진행과정(boot process) 컴퓨터 가동을 위해 파워버튼을 누르면 부트 로더가 준비동작에 들어감 POST(Power-On Self-Test) 수행 다른 BIOS들이 해당 준비동작에 들어감. 유저가 원할 경우 BIOS 세팅들에 접근을 위해 즉시 ‘키’ 조작 시도함 잠깐 동안의 메모리 테스트가 수행되고 여러 파라메타들이 세트됨. 플러그와 플레이 디바이스들이 준비동작에 들어감 DMA(Direct Memory Access)채널을 위한 자원들과 IRQ(Interrupt Request)할당됨 부트 디바이스들이 정해지고 준비동작에 들어감 OS가 준비동작에 들어감 POST (power on self test) 성공적인 부팅 및 적정 수행의 확인을 위해 필요하드웨어에 대해 행하는 테스트 수행하는 일 초기BIOS의 완벽한 보전 확인 주기억장치의 할당, 확인 및 그 크기(size)의 결정 시스템 버스(buses)와 시스템디바이스의 할당 및 시작 다른 BIOS들의 시작허용 (비디오 또는 그래픽카드 등) 사용자에게 BIOS시스템 구성 페이지에 접근할 수 있는 권한부여 부트 디바이스 할당 및 부트 파일을 가진 디바이스 찾기 운영체제에 의해 요구되는 그 외 준비관련 태스크들의 마무리 작업의 수행 버퍼링(buffering) 입출력장치의 느린 속도를 보완하는 한 가지 방법 중앙처리장치와 입출력장치 간의 시간적 불균형을 극복 미리 읽혀진 레코드들이 존재하는 곳은 주기억장치의 일부 [그림1-9] 버퍼를 이용한 출력의 예 입출력장치의 느린 속도를 보완하여, 유휴시간이 없도록 프로세서의 연산 과정과 함께 어떤 작업의 입출력을 동시에 수행하는 기능 스풀링(SPOOLing) 디스크(disk)를 매우 큰 버퍼처럼 사용하는 것 채널(channel) 출력장치와 중앙처리장치 사이에 입출력 전담 처리기 [그림1-10] 입출력 채널을 갖는 컴퓨터 시스템 선택 채널(select channel) 여러 개의 입출력장치가 연결되어 있다 하더라도 한 번에 단 하나의 입출력장치만을 선택적으로 지원 비교적 전송 속도가 빠른 입출력장치인 디스크나 CD-ROM 등의 입출력을 제어 멀티플렉서 채널(multiplexer channel) 다수의 저속도 입출력장치가 채널의 단일한 데이터 경로를 공유하면서 데이터를 전송 여러 개의 저속도 입출력장치가 멀티플렉서 채널에 연결되어 시분할(time­sharing) 형태로 제어 키보드나 프린터와 같은 비교적 전송 속도가 느린 입출력장치를 제어 채널과 중앙처리장치 간의 통신은 일반적으로 인터럽트(interrupt) [그림1-11] 다양한 형태의 채널 연결 구조 인터럽트(interrupt) 시스템에 예기치 않은 상황이 발생하였을 때, 그것을 운영체제에 알리기 위한 메커니즘 종류 입출력(I/O) 인터럽트 외부(external) 인터럽트 SVC(SuperVisor Call) 인터럽트 기계 검사(machine check) 인터럽트 프로그램 에러(program error) 인터럽트 재시작(restart) 인터럽트 구조 및 처리 [그림1-12] 인터럽트 처리 과정 [그림1-13] 인터럽트의 처리 과정 및 PSW 위치","link":"/Computer-Science/Operating-System/2019/08/06/Operating-System-01-introduce/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","link":"/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"BFS Searching","slug":"BFS-Searching","link":"/tags/BFS-Searching/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Counting Sort","slug":"Counting-Sort","link":"/tags/Counting-Sort/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"DFS Searching","slug":"DFS-Searching","link":"/tags/DFS-Searching/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"Parametric Search","slug":"Parametric-Search","link":"/tags/Parametric-Search/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"Insertion Sort","slug":"Insertion-Sort","link":"/tags/Insertion-Sort/"},{"name":"Quick Sort","slug":"Quick-Sort","link":"/tags/Quick-Sort/"},{"name":"Permutation","slug":"Permutation","link":"/tags/Permutation/"},{"name":"Combination","slug":"Combination","link":"/tags/Combination/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"Priority Queue","slug":"Priority-Queue","link":"/tags/Priority-Queue/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Issues","slug":"Issues","link":"/tags/Issues/"},{"name":"이슈해결","slug":"이슈해결","link":"/tags/이슈해결/"},{"name":"ArrayIndexOutOfBoundsException","slug":"ArrayIndexOutOfBoundsException","link":"/tags/ArrayIndexOutOfBoundsException/"},{"name":"이슈등록","slug":"이슈등록","link":"/tags/이슈등록/"},{"name":"Collections","slug":"Collections","link":"/tags/Collections/"},{"name":"Arrays","slug":"Arrays","link":"/tags/Arrays/"},{"name":"Review","slug":"Review","link":"/tags/Review/"},{"name":"NHN","slug":"NHN","link":"/tags/NHN/"},{"name":"Public Recruitment Session","slug":"Public-Recruitment-Session","link":"/tags/Public-Recruitment-Session/"},{"name":"채용설명회","slug":"채용설명회","link":"/tags/채용설명회/"},{"name":"Job Hunter","slug":"Job-Hunter","link":"/tags/Job-Hunter/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"}],"categories":[{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","link":"/categories/Computer-Science/Algorithm/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","link":"/categories/Computer-Science/Data-Structure/"},{"name":"Issues","slug":"Issues","link":"/categories/Issues/"},{"name":"Review","slug":"Review","link":"/categories/Review/"},{"name":"Devlog","slug":"Devlog","link":"/categories/Devlog/"},{"name":"Hexo","slug":"Devlog/Hexo","link":"/categories/Devlog/Hexo/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","link":"/categories/Computer-Science/Operating-System/"}]}