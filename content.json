{"pages":[{"title":"About","text":"ğŸ™‹â€ ì•ˆë…•í•˜ì„¸ìš”!ë„ì „í•˜ëŠ” ê²ƒì„ ì¦ê¸°ê³ , ëŠì„ì—†ì´ ì„±ì¥ì„ ì¶”êµ¬í•˜ëŠ”, í˜¸ê¸°ì‹¬ëŒ€ë§ˆì™•ì£¼ë‹ˆì–´ ê°œë°œì ê¹€ì°¬ë¯¸ì…ë‹ˆë‹¤! ğŸ’» ì°¬ë¯¸ì˜ ê°œë°œë¸”ë¡œê·¸Chanmiâ€™s Devlog(ì°¬ë¯¸ì˜ ê°œë°œë¸”ë¡œê·¸)ëŠ”ì•„ë˜ì™€ ê°™ì´ ê°œë°œ ë° ê¸°ìˆ ì— ëŒ€í•œ ë‚´ìš©ì„ ë‹¤ë£¨ê³ ì ìš´ì˜ì¤‘ì¸ ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì´ìŠˆ í•´ê²° ê´€ë¦¬ ì „ê³µ ë° ê°œë°œ ê³µë¶€ ê°œë°œì¼ì§€ ê¶ê¸ˆí•˜ì‹  ë‚´ìš©ì´ë‚˜ í‹€ë¦° ë‚´ìš©ì´ ìˆì„ ê²½ìš°, ì œ Githubë¡œ ì˜¤ì…”ì„œ Issuesì— ë‚¨ê²¨ì£¼ì„¸ìš”.í˜¹ì€ ê²Œì‹œë¬¼ ëŒ“ê¸€ë¡œ ë‚¨ê²¨ì£¼ì‹œë©´ ê°ì‚¬ë“œë¦½ë‹ˆë‹¤! ğŸ“« Contact Github: https://github.com/chanmi-kim Email: chanmi_dev@naver.com","link":"/About/index.html"}],"posts":[{"title":"ì•Œê³ ë¦¬ì¦˜ | ì‚½ì… ì •ë ¬ (Insertion Sort)","text":"Algorithm : Insertion Sort(ì‚½ì… ì •ë ¬) ì‚½ì… ì •ë ¬(Insertion Sort)ì€ ìë£Œ ë°°ì—´ì˜ ëª¨ë“  ìš”ì†Œë¥¼ ì•ì—ì„œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ì´ë¯¸ ì •ë ¬ëœ ë°°ì—´ ë¶€ë¶„ê³¼ ë¹„êµí•˜ì—¬, ìì‹ ì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ ì‚½ì…í•¨ìœ¼ë¡œì¨ ì •ë ¬ì„ ì™„ì„±í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ ë°ì´í„°ë¥¼ Insertion Sortë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ë ¬ í•˜ì‹œì˜¤. ë°ì´í„°ì˜ ìµœëŒ€ í¬ê¸°ëŠ” 100ì´ë‹¤. ì…ë ¥ ì¶œë ¥ 1 // ì „ì²´ Test case ìˆ˜ 5 // ë°ì´í„° í¬ê¸° 1 4 5 2 3 #1 1 2 3 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Scanner; class Solution { static int input[]; static int num; static void insertionSort() { for (int i = 1; i &lt; num; i++) { int temp = input[i]; int j = i - 1; while ((j &gt;= 0) &amp;&amp; (temp &lt; input[j])) { input[j + 1] = input[j]; j = j - 1; } input[j + 1] = temp; } } static void printResult() { int i; for (i = 0; i &lt; num; ++i) { System.out.print(input[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { num = sc.nextInt(); input = new int[num]; for (int i = 0; i &lt; num; i++) { input[i] = sc.nextInt(); } insertionSort(); System.out.print(\"#\" + test_case + \" \"); printResult(); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt; #define MAX_NUM 100 int input[MAX_NUM];int num; void insertionSort(void){ int temp; int i; int j; for (i = 1; i &lt; num; i++) { temp = input[i]; j = i - 1; while ((j &gt;= 0) &amp;&amp; (temp &lt; input[j])) { input[j + 1] = input[j]; j = j - 1; } input[j + 1] = temp; }} void printResult(void){ int i; for (i = 0; i &lt; num; ++i) { printf(\"%d \", input[i]); } printf(\"\\n\");} int main(void){ int T; int test_case; int i; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;num); for (i = 0; i &lt; num; i++) { scanf(\"%d\", &amp;input[i]); } insertionSort(); printf(\"#%d \", test_case); printResult(); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/24/Algorithm-Insertion-Sort/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | ì¬ê·€(Recursion)","text":"Algorithm : Recursion(ì¬ê·€) ì¬ê·€(Recursion)ëŠ” ìˆ˜í•™ì´ë‚˜ ì»´í“¨í„° ê³¼í•™ ë“±ì—ì„œ ìì‹ ì„ ì •ì˜í•  ë•Œ ìê¸° ìì‹ ì„ ì¬ì°¸ì¡°í•˜ëŠ” ë°©ë²•ì„ ëœ»í•©ë‹ˆë‹¤. ì£¼ë¡œ ì´ ë°©ë²•ì€ í•¨ìˆ˜ì— ì ìš©í•œ ì¬ê·€ í•¨ìˆ˜(Recursion Function)ì˜ í˜•íƒœë¡œ ë§ì´ ì‚¬ìš©ë©ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§€ëŠ” ìˆ˜ê°€ 1 ì´ìƒ 20 ì´í•˜ì˜ ìˆ˜ì¼ ë•Œ, ì£¼ì–´ì§„ ìˆ˜ì˜ Factorial ê°’ì„ êµ¬í•´ ì•„ë˜ì™€ ê°™ì´ ì¶œë ¥í•˜ì‹œì˜¤. ì…ë ¥ ì¶œë ¥ 3 // ì „ì²´ Test case ìˆ˜ 9 // Test case index 12 20 #1 9! = 362880 #2 12! = 479001600 #3 20! = 2432902008176640000 Java12345678910111213141516171819202122232425262728293031323334import java.util.Scanner; class Solution { static long factorial(int num) { if (num == 0) { return 1; } else { return num * factorial(num - 1); } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; ++test_case) { int num = sc.nextInt(); long value = factorial(num); System.out.println(\"#\" + test_case + \" \" + num + \"! = \" + value); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt; long long factorial(int num){ if (num == 0) { return 1; } else { return num * factorial(num - 1); }} int main(void){ int test_case; int T; int num; long long value; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; ++test_case) { scanf(\"%d\", &amp;num); value = factorial(num); printf(\"#%d %d! = %lld\\n\", test_case, num, value); }} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/20/Algorithm-Recursion/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | í€µ ì •ë ¬ (Quick Sort)","text":"Algorithm : Quick Sort(í€µ ì •ë ¬) í€µ ì •ë ¬(Quick Sort)ì€ ê¸°ì¤€í‚¤(pivot)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì‘ê±°ë‚˜ ê°™ì€ ê°’ì„ ì§€ë‹Œ ë°ì´í„°ëŠ” ì•ìœ¼ë¡œ, í° ê°’ì„ ì§€ë‹Œ ë°ì´í„°ëŠ” ë’¤ë¡œ ê°€ë„ë¡ í•˜ì—¬ ì‘ì€ ê°’ì„ ê°–ëŠ” ë°ì´í„°ì™€ í° ê°’ì„ ê°–ëŠ” ë°ì´í„°ë¡œ ë¶„ë¦¬í•´ê°€ë©° ì •ë ¬í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ ë°ì´í„°ë¥¼ Quick Sortë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ë ¬í•˜ì‹œì˜¤. ë°ì´í„°ì˜ ìµœëŒ€ í¬ê¸°ëŠ” 100ì´ë‹¤. ì…ë ¥ ì¶œë ¥ 1 // ì „ì²´ Test case ìˆ˜ 5 // ë°ì´í„° í¬ê¸° 1 4 5 2 3 #1 1 2 3 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Scanner; class Solution { static int input[]; static int num; static void quickSort(int first, int last) { int temp; if (first &lt; last) { int pivot = first; int i = first; int j = last; while (i &lt; j) { while (input[i] &lt;= input[pivot] &amp;&amp; i &lt; last) { i++; } while (input[j] &gt; input[pivot]) { j--; } if (i &lt; j) { temp = input[i]; input[i] = input[j]; input[j] = temp; } } temp = input[pivot]; input[pivot] = input[j]; input[j] = temp; quickSort(first, j - 1); quickSort(j + 1, last); } } static void printResult() { for (int i = 0; i &lt; num; ++i) { System.out.print(input[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { num = sc.nextInt(); input = new int[num]; for (int i = 0; i &lt; num; i++) { input[i] = sc.nextInt(); } quickSort(0, num - 1); System.out.print(\"#\" + test_case + \" \"); printResult(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt; #define MAX_NUM 100 int input[MAX_NUM];int num; void quickSort(int first, int last){ int pivot; int i; int j; int temp; if (first &lt; last) { pivot = first; i = first; j = last; while (i &lt; j) { while (input[i] &lt;= input[pivot] &amp;&amp; i &lt; last) { i++; } while (input[j] &gt; input[pivot]) { j--; } if (i &lt; j) { temp = input[i]; input[i] = input[j]; input[j] = temp; } } temp = input[pivot]; input[pivot] = input[j]; input[j] = temp; quickSort(first, j - 1); quickSort(j + 1, last); }} void printResult(void){ int i; for (i = 0; i &lt; num; ++i) { printf(\"%d \", input[i]); } printf(\"\\n\");} int main(void){ int T; int test_case; int i; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;num); for (i = 0; i &lt; num; i++) { scanf(\"%d\", &amp;input[i]); } quickSort(0, num - 1); printf(\"#%d \", test_case); printResult(); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/29/Algorithm-Quick-Sort/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | ê³„ìˆ˜ ì •ë ¬ (Counting Sort)","text":"Algorithm : Counting Sort(ê³„ìˆ˜ ì •ë ¬) ê³„ìˆ˜ ì •ë ¬(Counting sort)ëŠ” í•­ëª©ë“¤ì˜ ìˆœì„œë¥¼ ê²°ì •í•˜ê¸° ìœ„í•´ ì§‘í•©ì— ê° í•­ëª©ì´ ëª‡ ê°œì”© ìˆëŠ”ì§€ ì„¸ëŠ” ì‘ì—…ì„ í•˜ë©´ì„œ ì •ë ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ ì •ìˆ˜ë“¤ì„ Counting Sortë¥¼ ì´ìš©í•˜ì—¬ ì •ë ¬í•˜ê³  ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì¶œë ¥í•˜ë¼. (ì£¼ì–´ì§„ ì •ìˆ˜ë“¤ì€ ì¤‘ë³µê°€ëŠ¥) ì…ë ¥ ì¶œë ¥ 2 // # of test case 10 // # of data set 0 2 9 4 5 1 0 7 3 9 5 4 9 5 1 3 #1 0 0 1 2 3 4 5 7 9 9 #2 1 3 4 5 9 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Scanner; class Solution { static final int MAX_N = 100; static final int MAX_DIGIT = 10; static int N; // # of data set static int arr[]; static int cnt[] = new int[MAX_DIGIT]; static int sortedArr[]; static void calculateDigitNumber() { for (int i = 0; i &lt; N; i++) { cnt[arr[i]]++; } for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = cnt[i-1] + cnt[i]; } } static void executeCountingSort() { for (int i = N-1; i &gt;= 0; i--) { sortedArr[--cnt[arr[i]]] = arr[i]; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { N = sc.nextInt(); arr = new int[N]; sortedArr = new int[N]; for (int i = 0; i &lt; N; i++) { arr[i] = sc.nextInt(); } // initialize for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = 0; } calculateDigitNumber(); executeCountingSort(); //print the sorted digits System.out.print(\"#\" + test_case + \" \"); for (int i = 0; i &lt; N; i++) { System.out.print(sortedArr[i] + \" \"); } System.out.println(); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt; #define MAX_N 100#define MAX_DIGIT 10 int N; // # of data setint arr[MAX_N];int cnt[MAX_DIGIT];int sortedArr[MAX_N]; void calculateDigitNumber(){ for (int i = 0; i &lt; N; i++) { cnt[arr[i]]++; } for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = cnt[i-1] + cnt[i]; }} void executeCountingSort(){ for (int i = N-1; i &gt;= 0; i--) { sortedArr[--cnt[arr[i]]] = arr[i]; }} int main(void){ int T; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;arr[i]); } // initialize for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = 0; } calculateDigitNumber(); executeCountingSort(); //print the sorted digits printf(\"#%d \", test_case); for (int i = 0; i &lt; N; i++) { printf(\"%d \", sortedArr[i]); } printf(\"\\n\"); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/30/Algorithm-Counting-Sort/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | ì´ì§„ íƒìƒ‰ (Binary Search)","text":"Algorithm : Binary Search(ì´ì§„ íƒìƒ‰) ì´ì§„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜(Binary search algorithm)ì€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ì—ì„œ íŠ¹ì •í•œ ê°’ì˜ ìœ„ì¹˜ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì²˜ìŒ ì¤‘ê°„ì˜ ê°’ì„ ì„ì˜ì˜ ê°’ìœ¼ë¡œ ì„ íƒí•˜ì—¬, ê·¸ ê°’ê³¼ ì°¾ê³ ì í•˜ëŠ” ê°’ì˜ í¬ê³  ì‘ìŒì„ ë¹„êµí•˜ëŠ” ë°©ì‹ì„ ì±„íƒí•˜ê³  ìˆìŠµë‹ˆë‹¤. ë§Œì•½ ì²˜ìŒ ì„ íƒí•œ ì¤‘ì•™ê°’ì´ ì°¾ëŠ” ê°’ë³´ë‹¤ í¬ë©´ ê·¸ ê°’ì€ ìƒˆë¡œìš´ ìµœê³ ê°’ì´ ë˜ê³ , ì‘ìœ¼ë©´ ê·¸ ê°’ì€ ìƒˆë¡œìš´ ìµœí•˜ê°’ì´ ë©ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì •ë ¬ëœ ì •ìˆ˜ë°°ì—´ì—ì„œ Binary Searchë¥¼ ì´ìš©í•˜ì—¬ ì œì‹œëœ ìˆ«ìë“¤ì„ ì°¾ì•„ë¼. ìˆìœ¼ë©´ í•´ë‹¹ ì¸ë±ìŠ¤ë¥¼ ì¶œë ¥í•˜ê³ , ì—†ìœ¼ë©´ -1 ë¥¼ ì¶œë ¥í•˜ë¼. (2 â‰¤ M â‰¤ 100) ì…ë ¥ ì¶œë ¥ 2 // # of test case T 12 // # of element in array M 5 // # of numbers to search N 3 7 28 29 43 49 55 58 69 77 79 99 // sorted integer array 8 49 58 44 7 // numbers to search 7 3 3 4 5 6 7 8 9 1 2 3 #1 -1 5 7 -1 1 #2 -1 -1 0 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.Scanner; class Solution { static final int MAX_M = 100; static int T; // # of test case static int M; // # of element in array static int N; // # of numbers to search static int arr[]; static void binarySearch(int[] arr, int low, int high, int target) { int mid; if (low &gt; high) { System.out.print(\"-1 \"); return; } mid = (low + high) / 2; if (target &lt; arr[mid]) { binarySearch(arr, low, mid - 1, target); } else if (arr[mid] &lt; target) { binarySearch(arr, mid + 1, high, target); } else { System.out.print(mid + \" \"); return; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { System.out.print(\"#\" + test_case + \" \"); M = sc.nextInt(); N = sc.nextInt(); arr = new int[M]; for (int i = 0; i &lt; M; i++) { arr[i] = sc.nextInt(); } for (int i = 0; i &lt; N; i++) { int targetValue = sc.nextInt(); binarySearch(arr, 0, M-1, targetValue); } System.out.println(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt; #define MAX_M 100 int T; // # of test caseint M; // # of element in arrayint N; // # of numbers to searchint arr[MAX_M]; void binarySearch(int* arr, int low, int high, int target){ int mid; if (low &gt; high) { printf(\"-1 \"); return; } mid = (low + high) / 2; if (target &lt; arr[mid]) { binarySearch(arr, low, mid - 1, target); } else if (arr[mid] &lt; target) { binarySearch(arr, mid + 1, high, target); } else { printf(\"%d \", mid); return; }} int main(void){ int targetValue; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { printf(\"#%d \", test_case); scanf(\"%d %d\", &amp;M, &amp;N); for (int i = 0; i &lt; M; i++) { scanf(\"%d\", &amp;arr[i]); } for (int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;targetValue); binarySearch(arr, 0, M-1, targetValue); } printf(\"\\n\"); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/31/Algorithm-Binary-Search/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | ê¹Šì´ ìš°ì„  íƒìƒ‰ (DFS Searching)","text":"Algorithm : DFS Searching (ê¹Šì´ ìš°ì„  íƒìƒ‰) ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS Searching, Depth First Searching)ì€ ë§¹ëª©ì  íƒìƒ‰ë°©ë²•ì˜ í•˜ë‚˜ë¡œ í•œ ë…¸ë“œë¥¼ ì‹œì‘ìœ¼ë¡œ ì¸ì ‘í•œ ë‹¤ë¥¸ ë…¸ë“œë¥¼ ì¬ê·€ì ìœ¼ë¡œ íƒìƒ‰í•´ê°€ê³  ëê¹Œì§€ íƒìƒ‰í•˜ë©´ ë‹¤ì‹œ ìœ„ë¡œ ì™€ì„œ ë‹¤ìŒì„ íƒìƒ‰í•˜ì—¬ ê²€ìƒ‰í•©ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ìˆ«ìê°€ ìˆëŠ” ì›ì€ ì •ì (Vertex)ë¼ê³  í•˜ê³ , ì •ì ê³¼ ì •ì ì„ ì‡ëŠ” ì—°ê²°ì„ ì„ ê°„ì„ (Edge)ì´ë¼ê³  í•œë‹¤. ì •ì ì˜ ìµœëŒ€ ê°œìˆ˜ëŠ” 30ê°œì´ë‹¤. ì •ì ê³¼ ì •ì ì˜ ì—°ê²°ê´€ê³„ê°€ ì¸ì ‘í–‰ë ¬ë¡œ ì£¼ì–´ì¡Œì„ ë•Œ, DFSë¥¼ ì´ìš©í•˜ì—¬ ì‹œì‘ ì •ì ìœ¼ë¡œë¶€í„° ëª¨ë“  ì •ì ì„ íƒìƒ‰í•œ ê²°ê³¼ë¥¼ ìˆœì„œëŒ€ë¡œ í™”ë©´ì— ì¶œë ¥í•˜ì‹œì˜¤. ì…ë ¥ ì¶œë ¥ 1 //test case ê°œìˆ˜ 8 1 // ì •ì ì˜ ê°œìˆ˜, ì‹œì‘ ì •ì  1 2 // ì •ì  ê°„ ì—°ê²° ê´€ê³„. 1ê³¼ 2ê°€ ì—°ê²° 1 3 2 4 2 5 4 8 5 8 3 6 3 7 6 8 7 8 -1 -1 // ì…ë ¥ ë #1 1 2 4 8 5 6 3 7 // ë°©ë¬¸í•œ ì •ì  ìˆœì„œ Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Scanner; class Solution { static final int MAX_VERTEX = 30; static int vertex; static int map[][] = new int[MAX_VERTEX][MAX_VERTEX]; static int visit[] = new int[MAX_VERTEX]; static void depthFirstSearch(int v) { visit[v] = 1; for (int i = 1; i &lt;= vertex; i++) { if (map[v][i] == 1 &amp;&amp; visit[i] == 0) { System.out.printf(\"%d \", i); depthFirstSearch(i); } } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { vertex = sc.nextInt(); int start = sc.nextInt(); map = new int[MAX_VERTEX][MAX_VERTEX]; visit = new int[MAX_VERTEX]; while (true) { int v1 = sc.nextInt(); int v2 = sc.nextInt(); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } System.out.printf(\"#%d \", test_case); System.out.printf(\"%d \", start); depthFirstSearch(start); System.out.printf(\"\\n\"); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt; #define MAX_VERTEX 30 int vertex;int map[MAX_VERTEX][MAX_VERTEX];int visit[MAX_VERTEX]; void depthFirstSearch(int v){ int i; visit[v] = 1; for (i = 1; i &lt;= vertex; i++) { if (map[v][i] == 1 &amp;&amp; !visit[i]) { printf(\"%d \", i); depthFirstSearch(i); } }} int main(void){ int T; int test_case; int i,j; int start; int v1; int v2; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { for (i = 0; i &lt; MAX_VERTEX; i++) { for (j = 0; j &lt; MAX_VERTEX; j++) { map[i][j] = 0; } visit[i] = 0; } scanf(\"%d %d\", &amp;vertex, &amp;start); while (true) { scanf(\"%d %d\", &amp;v1, &amp;v2); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } printf(\"#%d \", test_case); printf(\"%d \", start); depthFirstSearch(start); printf(\"\\n\"); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/01/Algorithm-DFS-Searching/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | ë„ˆë¹„ ìš°ì„  íƒìƒ‰ (BFS Searching)","text":"Algorithm : BFS Searching (ë„ˆë¹„ ìš°ì„  íƒìƒ‰) ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS Searching, Breadth First Search)ì€ ë§¹ëª©ì  íƒìƒ‰ë°©ë²•ì˜ í•˜ë‚˜ë¡œ ì‹œì‘ ì •ì ì„ ë°©ë¬¸í•œ í›„ ì‹œì‘ ì •ì ì— ì¸ì ‘í•œ ëª¨ë“  ì •ì ë“¤ì„ ìš°ì„  ë°©ë¬¸í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ìˆ«ìê°€ ìˆëŠ” ì›ì€ ì •ì (Vertex)ë¼ê³  í•˜ê³ , ì •ì ê³¼ ì •ì ì„ ì‡ëŠ” ì—°ê²°ì„ ì„ ê°„ì„ (Edge)ì´ë¼ê³  í•œë‹¤. ì •ì ì˜ ìµœëŒ€ ê°œìˆ˜ëŠ” 30ê°œì´ë‹¤. ì •ì ê³¼ ì •ì ì˜ ì—°ê²°ê´€ê³„ê°€ ì¸ì ‘í–‰ë ¬ë¡œ ì£¼ì–´ì¡Œì„ ë•Œ, BFSë¥¼ ì´ìš©í•˜ì—¬ ì‹œì‘ ì •ì ìœ¼ë¡œë¶€í„° ëª¨ë“  ì •ì ì„ íƒìƒ‰í•œ ê²°ê³¼ë¥¼ ìˆœì„œëŒ€ë¡œ í™”ë©´ì— ì¶œë ¥í•˜ì‹œì˜¤. ì…ë ¥ ì¶œë ¥ 1 //test case ê°œìˆ˜ 8 1 // ì •ì ì˜ ê°œìˆ˜, ì‹œì‘ ì •ì  1 2 // ì •ì  ê°„ ì—°ê²° ê´€ê³„. 1ê³¼ 2ê°€ ì—°ê²° 1 3 2 4 2 5 4 8 5 8 3 6 3 7 6 8 7 8 -1 -1 // ì…ë ¥ ë #1 1 2 3 4 5 6 7 8 // ë°©ë¬¸í•œ ì •ì  ìˆœì„œ Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner; class Solution { static final int MAX_VERTEX = 30; static int num; static int map[][]; static int visit[]; static int queue[]; static int rear, front; static void breadthFirstSearch(int vertex) { visit[vertex] = 1; System.out.print(vertex + \" \"); queue[rear++] = vertex; while (front &lt; rear) { vertex = queue[front++]; for (int i = 1; i &lt;= num; i++) { if (map[vertex][i] == 1 &amp;&amp; visit[i] == 0) { visit[i] = 1; System.out.printf(\"%d \", i); queue[rear++] = i; } } } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { map = new int[MAX_VERTEX][MAX_VERTEX]; visit = new int[MAX_VERTEX]; queue = new int[MAX_VERTEX]; num = sc.nextInt(); int start = sc.nextInt(); while (true) { int v1 = sc.nextInt(); int v2 = sc.nextInt(); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } System.out.printf(\"#%d \", test_case); breadthFirstSearch(start); System.out.printf(\"\\n\"); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt; #define MAX_VERTEX 30 int num;int map[MAX_VERTEX][MAX_VERTEX];int visit[MAX_VERTEX];int queue[MAX_VERTEX];int rear, front; void breadthFirstSearch(int vertex){ int i; visit[vertex] = 1; printf(\"%d \", vertex); queue[rear++] = vertex; while (front &lt; rear) { vertex = queue[front++]; for (i = 1; i &lt;= num; i++) { if (map[vertex][i] == 1 &amp;&amp; !visit[i]) { visit[i] = 1; printf(\"%d \", i); queue[rear++] = i; } } }} int main(void){ int T; int test_case; int i,j; int start; int v1; int v2; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { for (i = 0; i &lt; MAX_VERTEX; i++) { for (j = 0; j &lt; MAX_VERTEX; j++) { map[i][j] = 0; } visit[i] = 0; queue[i] = 0; } front = 0; rear = 0; scanf(\"%d %d\", &amp;num, &amp;start); while (true) { scanf(\"%d %d\", &amp;v1, &amp;v2); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } printf(\"#%d \", test_case); breadthFirstSearch(start); printf(\"\\n\"); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/02/Algorithm-BFS-Searching/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | ë§¤ê°œë³€ìˆ˜ íƒìƒ‰ (Parametric Search)","text":"Algorithm : Parametric Search (ë§¤ê°œë³€ìˆ˜ íƒìƒ‰) ë§¤ê°œë³€ìˆ˜ íƒìƒ‰(Parametric Search)ì€ ì–´ë–¤ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í•´ë¥¼ ë°”ë¡œ êµ¬í•´ë‚´ëŠ” ê²ƒì´ ì•„ë‹ˆê³ , ì„ì˜ì˜ ê°’ì„ ë˜ì§€ê³  ë§ëŠ”ì§€ í™•ì¸í•´ê°€ë©° í•´ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ê¸¸ì´ê°€ ê°ê° ë‹¤ë¥¸ Kê°œì˜ ë¦¬ë³¸ì„ ê°€ì§€ê³  ìˆë‹¤. ê³µì˜ˆì‘í’ˆì„ ë§Œë“¤ê¸° ìœ„í•´ ê°€ì§€ê³  ìˆëŠ” ë¦¬ë³¸ì„ ì˜ë¼ì„œ ê¸¸ì´ê°€ ë™ì¼í•œ Nê°œì˜ ë¦¬ë³¸ì¬ë£Œë¥¼ ë§Œë“¤ë ¤ê³  í•œë‹¤. ë¦¬ë³¸ì¬ë£Œì˜ ìµœëŒ€ ê¸¸ì´ë¥¼ êµ¬í•˜ì‹œì˜¤. ( 1 &lt;= K &lt;= 10,000; 1 &lt;= N &lt;= 1,000,000; K &lt;= N ) ì†ì‹¤ë˜ëŠ” ê¸¸ì´ëŠ” ì—†ìŒ ë§Œë“¤ ìˆ˜ ì—†ëŠ” ê²½ìš°ëŠ” ì—†ë‹¤ ì´ë¯¸ ìë¥¸ ë¦¬ë³¸ì€ ë¶™ì¼ ìˆ˜ ì—†ë‹¤ ìë¥¼ ë•ŒëŠ” ì •ìˆ˜ cm ë‹¨ìœ„ë¡œ ìë¥¸ë‹¤ ì…ë ¥ ì¶œë ¥ 1 // test case ê°œìˆ˜ 4 // ê°€ì§€ê³  ìˆëŠ” ë¦¬ë³¸ì˜ ê°œìˆ˜ K 11 // í•„ìš”í•œ ë¦¬ë³¸ì¬ë£Œì˜ ê°œìˆ˜ N 802 743 457 539 #1 200 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner; class Solution { static int K; static int N; static int low, high, mid, numRibbonTape, max; static int sizeRibbonTape[]; static void search() { mid = low + (high - low) / 2; numRibbonTape = 0; for (int i = 0; i &lt; K ; i++) { numRibbonTape += (sizeRibbonTape[i] / mid); } if (numRibbonTape &gt;= N) { low = mid + 1; if (max &lt; mid) max = mid; } else { high = mid - 1; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { low = 1; high = 0 ; max = -1; K = sc.nextInt(); N = sc.nextInt(); sizeRibbonTape = new int[K]; for (int i = 0; i &lt; K; i++) { sizeRibbonTape[i] = sc.nextInt(); if ( high &lt; sizeRibbonTape[i] ) { high = sizeRibbonTape[i] ; } } while (low &lt;= high) { search(); } System.out.println(\"#\" + test_case + \" \" + max); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt; #define MAX_RIBBON 100 int K;int N;int low, high, mid, numRibbonTape, max;int sizeRibbonTape[MAX_RIBBON]; void search(){ mid = low + (high - low) / 2; numRibbonTape = 0; for (int i = 0; i &lt; K ; i++) { numRibbonTape += (sizeRibbonTape[i] / mid); } if (numRibbonTape &gt;= N) { low = mid + 1; if (max &lt; mid) max = mid; } else { high = mid - 1; }} int main(int argc, char** argv){ int T; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { low = 1; high = 0 ; max = -1; scanf(\"%d %d\", &amp;K, &amp;N); for (int i = 0; i &lt; K; i++) { scanf(\"%d\", &amp;sizeRibbonTape[i]); if ( high &lt; sizeRibbonTape[i] ) { high = sizeRibbonTape[i] ; } } while (low &lt;= high) { search(); } printf(\"#%d \", test_case); printf(\"%d\\n\", max); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/03/Algorithm-Parametric-Search/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | ë™ì  ê³„íšë²• (Dynamic Programming)","text":"Algorithm : Dynamic Programming (ë™ì  ê³„íšë²•) ë™ì  ê³„íšë²•(Dynamic programming)ì€ ë³µì¡í•œ ë¬¸ì œë¥¼ í’€ê¸°ìœ„í•´ì„œ ê°„ë‹¨í•œ ì—¬ëŸ¬ ê°œì˜ í•˜ìœ„ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ í‘¼ ë‹¤ìŒ, ê·¸ê²ƒì„ ê²°í•©í•˜ì—¬ ëª©ì ì— ë„ë‹¬í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ìƒê·¼ì´ì˜ ì—¬ë™ìƒ ìƒëƒ¥ì´ëŠ” ë¬¸ë°©êµ¬ì—ì„œ ìŠ¤í‹°ì»¤ 2nê°œë¥¼ êµ¬ë§¤í–ˆë‹¤. ìŠ¤í‹°ì»¤ëŠ” ê·¸ë¦¼ (a)ì™€ ê°™ì´ 2í–‰ nì—´ë¡œ ë°°ì¹˜ë˜ì–´ ìˆë‹¤. ìƒëƒ¥ì´ëŠ” ìŠ¤í‹°ì»¤ë¥¼ ì´ìš©í•´ ì±…ìƒì„ ê¾¸ë¯¸ë ¤ê³  í•œë‹¤. ìƒëƒ¥ì´ê°€ êµ¬ë§¤í•œ ìŠ¤í‹°ì»¤ì˜ í’ˆì§ˆì€ ë§¤ìš° ì¢‹ì§€ ì•Šë‹¤. ìŠ¤í‹°ì»¤ í•œ ì¥ì„ ë–¼ë©´, ê·¸ ìŠ¤í‹°ì»¤ì™€ ë³€ì„ ê³µìœ í•˜ëŠ” ìŠ¤í‹°ì»¤ëŠ” ëª¨ë‘ ì°¢ì–´ì ¸ì„œ ì‚¬ìš©í•  ìˆ˜ ì—†ê²Œ ëœë‹¤. ì¦‰, ë—€ ìŠ¤í‹°ì»¤ì˜ ì™¼ìª½, ì˜¤ë¥¸ìª½, ìœ„, ì•„ë˜ì— ìˆëŠ” ìŠ¤í‹°ì»¤ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ê²Œ ëœë‹¤. ì…ë ¥ ì¶œë ¥ 2 5 50 10 100 20 40 30 50 70 10 60 7 10 30 10 50 100 20 40 20 40 30 50 60 20 80 #1 260 #2 290 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Scanner; class Solution { static int N; static int dp[][]; static int board[][]; static int max(int a, int b) { return (a&lt;b) ? b : a; } static void findSticker() { dp[0][0] = board[0][0]; dp[1][0] = board[1][0]; dp[0][1] = dp[1][0] + board[0][1]; dp[1][1] = dp[0][0] + board[1][1]; for (int i = 2; i &lt; N; i++) { dp[0][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[0][i] = max(dp[1][i - 1], dp[0][i]); dp[0][i] += board[0][i]; dp[1][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[1][i] = max(dp[0][i - 1], dp[1][i]); dp[1][i] += board[1][i]; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { N = sc.nextInt(); board = new int[2][N]; dp = new int[2][N]; for (int j = 0; j &lt; 2; j++) { for (int i = 0; i &lt; N; i++) { board[j][i] = sc.nextInt(); } } findSticker(); System.out.println(\"#\" + test_case + \" \" + max(dp[0][N - 1], dp[1][N - 1])); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt; int N;int dp[2][100001];int board[2][100001]; const int max(const int a, const int b) { return (a&lt;b) ? b : a;} void findSticker() { dp[0][0] = board[0][0]; dp[1][0] = board[1][0]; dp[0][1] = dp[1][0] + board[0][1]; dp[1][1] = dp[0][0] + board[1][1]; for (int i = 2; i &lt; N; i++) { dp[0][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[0][i] = max(dp[1][i - 1], dp[0][i]); dp[0][i] += board[0][i]; dp[1][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[1][i] = max(dp[0][i - 1], dp[1][i]); dp[1][i] += board[1][i]; }} int main() { int T; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { printf(\"#%d \", test_case); scanf(\"%d\", &amp;N); for (int j = 0; j &lt; 2; j++) { for (int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;board[j][i]); } } findSticker(); printf(\"%d\\n\", max(dp[0][N - 1], dp[1][N - 1])); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/04/Algorithm-Dynamic-Programming/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | ìˆœì—´ ì¡°í•© (Permutation & Combination)","text":"Algorithm : Permutation &amp; Combination (ìˆœì—´ ì¡°í•©) ìˆœì—´(Permutation)ì€ ìˆœì„œê°€ ë¶€ì—¬ëœ ì„ì˜ì˜ ì§‘í•©ì„ ë‹¤ë¥¸ ìˆœì„œë¡œ ë’¤ì„ëŠ” ì—°ì‚°ì´ë©°, ì¡°í•©(Combination)ì€ ì§‘í•©ì—ì„œ ì¼ë¶€ ì›ì†Œë¥¼ ì·¨í•´ ë¶€ë¶„ ì§‘í•©ì„ ë§Œë“œëŠ” ë°©ë²•ì„ ë§í•©ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ ë¬¸ìì—´ str (ê¸¸ì´ n)ì— ëŒ€í•´ ì•„ë˜ ë‘ ê°€ì§€ë¥¼ ì°¨ë¡€ë¡œ ì¶œë ¥í•˜ì‹œì˜¤. 1. strì˜ nê°œ characterë¥¼ ì¼ë ¬ë¡œ ë°°ì—´í•˜ëŠ” ëª¨ë“  ê²½ìš°ë¥¼ ì¶œë ¥í•˜ì‹œì˜¤. 2. strì˜ nê°œ character ì¤‘ kê°œë¥¼ ì·¨í•˜ëŠ” ëª¨ë“  ê²½ìš°ë¥¼ ì¶œë ¥í•˜ì‹œì˜¤. (ì œí•œì‚¬í•­: ì£¼ì–´ì§„ stringì— ë™ì¼í•œ ì•ŒíŒŒë²³ì´ ì¤‘ë³µìœ¼ë¡œ í¬í•¨ë˜ì§€ ì•ŠìŒ. Stringì˜ maximum sizeëŠ” 10. k &lt;= n.) ì…ë ¥ ì¶œë ¥ 1 // # of test case ABCD 3 // n 2 // k #1 ABC ACB BAC BCA CBA CAB AB AC BC Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.Scanner; class Solution{ static final int MAX_STRING_LENGTH = 10; static int stackTop = 0; static char[] combinationStack = new char[MAX_STRING_LENGTH]; static void printCString(char[] str) { for (int i = 0; i &lt; str.length &amp;&amp; str[i] != 0; i++) { System.out.print(str[i]); } System.out.print(\"\\n\"); } static void swap(char[] str, int x, int y) { char temp = str[x]; str[x] = str[y]; str[y] = temp; } static void permutation(char[] str, int l, int r) { if (l == r) { printCString(str); } else { for (int i = l; i &lt;= r; i++) { swap(str, l, i); permutation(str, l+1, r); swap(str, l, i); //backtrack } } } static void push(char ch) { combinationStack[stackTop++] = ch; combinationStack[stackTop] = '\\0'; } static void pop() { combinationStack[--stackTop] = '\\0'; } static void combination(char[] str, int length, int offset, int k) { if (k == 0) { printCString(combinationStack); return; } for (int i = offset; i &lt;= length - k; ++i) { push(str[i]); combination(str, length, i+1, k-1); pop(); } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { String input = sc.next(); int N = sc.nextInt(); int K = sc.nextInt(); char[] str = input.toCharArray(); System.out.printf(\"#%d\\n\", test_case); str[N] = 0; permutation(str, 0, N-1); combination(str, N, 0, K); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt; #define MAX_STRING_LENGTH 10 int stackTop = 0;char combinationStack[MAX_STRING_LENGTH]; void swap(char *x, char *y){ char temp; temp = *x; *x = *y; *y = temp;} void permutation(char *str, int l, int r){ if (l == r) { printf(\"%s\\n\", str); } else { for (int i = l; i &lt;= r; i++) { swap((str+l), (str+i)); permutation(str, l+1, r); swap((str+l), (str+i)); //backtrack } }} void push(char ch) { combinationStack[stackTop++] = ch; combinationStack[stackTop] = '\\0';} void pop() { combinationStack[--stackTop] = '\\0';} void combination(const char* str, int length, int offset, int k) { if (k == 0) { printf(\"%s\\n\", combinationStack); return; } for (int i = offset; i &lt;= length - k; ++i) { push(str[i]); combination(str, length, i+1, k-1); pop(); }} int main(){ int N, K, T; char str[MAX_STRING_LENGTH]; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%s%d%d\", str, &amp;N, &amp;K); str[N] = 0; printf(\"#%d\\n\", test_case); permutation(str, 0, N-1); combination(str, N, 0, K); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/05/Algorithm-Permutation-and-Combination/"},{"title":"ì•Œê³ ë¦¬ì¦˜ | ë‹¤ìµìŠ¤íŠ¸ë¼ (Dijkstra)","text":"Algorithm : Dijkstra (ë‹¤ìµìŠ¤íŠ¸ë¼) ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜(Dijkstra)ì€ ì–´ë–¤ ë³€ë„ ìŒìˆ˜ ê°€ì¤‘ì¹˜ë¥¼ ê°–ì§€ ì•ŠëŠ” ìœ í–¥ ê·¸ë˜í”„ì—ì„œ ì£¼ì–´ì§„ ì¶œë°œì ê³¼ ë„ì°©ì  ì‚¬ì´ì˜ ìµœë‹¨ ê²½ë¡œ ë¬¸ì œë¥¼ í‘¸ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ë°©í–¥ì´ ìˆëŠ” ê·¸ë˜í”„ì—ì„œ ê¼­ì§€ì ë“¤ì„ ì—°ê²°í•˜ëŠ” ë¹„ìš©ì´ í• ë‹¹ ë˜ì—ˆì„ ë•Œ ì„ì˜ì˜ ê¼­ì§€ì ì—ì„œ ë‹¤ë¥¸ ê¼­ì§€ì ìœ¼ë¡œ ê°€ëŠ” ê²½ë¡œë“¤ ì¤‘ì—ì„œ ë¹„ìš©ì´ ê°€ì¥ ì ê²Œ ë“œëŠ” ê²½ë¡œ, ì¦‰ ë‘ ì •ì  ì‚¬ì´ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ì•„ë¼. ì…ë ¥ ê°’ ì²«ë²ˆì§¸ ë¼ì¸ì—ëŠ” ì „ì²´ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ê°œìˆ˜ê°€ ì…ë ¥ëœë‹¤. ë‘ë²ˆì§¸ ë¼ì¸ì—ëŠ” ì •ì ì˜ ê°œìˆ˜, ê·¸ë¦¬ê³  ì‹œì‘ ì •ì , ë„ì°© ì •ì ì´ ì…ë ¥ëœë‹¤. ì´ë•Œ, ì •ì ì˜ ìµœëŒ€ ê°œìˆ˜ëŠ” 100ì´ë‹¤. ì„¸ë²ˆì§¸ ë¼ì¸ì—ëŠ” ì •ì ì„ ì‡ëŠ” ê°„ì„  ê°œìˆ˜(m)ê°€ ì…ë ¥ëœë‹¤. ë„¤ë²ˆì§¸ ë¼ì¸ë¶€í„°ëŠ” ì—°ê²° ëœ ì •ì  ê°’ 2ê°œì™€ ê°„ì„ ì— í• ë‹¹ ëœ ë¹„ìš©ì´ më²ˆ ë“¤ì–´ì˜¨ë‹¤. ì´ë•Œ ê°„ì„  ë°©í–¥ì€ ì²«ë²ˆì§¸ ì…ë ¥ëœ ì •ì ì—ì„œ ë‘ë²ˆì§¸ ì…ë ¥ëœ ì •ì ìœ¼ë¡œ ê°€ëŠ” ë°©í–¥ì´ë‹¤. ì…ë ¥ ì¶œë ¥ 1 // test case ê°œìˆ˜ 7 1 7 // ì •ì ì˜ ê°œìˆ˜, ê·¸ë¦¬ê³  ì‹œì‘ ì •ì , ë„ì°© ì •ì  9 // ê°„ì„  ê°œìˆ˜ 1 2 4 // 1-&gt;2, ë¹„ìš©ì€ 4 1 3 2 2 4 1 2 5 2 3 4 7 3 6 3 4 7 3 5 7 1 6 7 5 #1 7 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.Scanner; class Solution{ static final int N = 100; static final int INF = 100000; static int[][] map = new int[N+1][N+1]; static boolean[] visit = new boolean[N+1]; static int[] dist = new int[N+1]; static int vertex; static int edge; static int start; static int end; public static void dijkstra() { int v = 0; dist[start] = 0; for (int i = 1; i &lt;= vertex; i++) { int min = INF; for (int j = 1; j &lt;= vertex; j++) { if (visit[j] == false &amp;&amp; min &gt; dist[j]) { min = dist[j]; v = j; } } visit[v] = true; for (int j = 1; j &lt;= vertex; j++) { if (dist[j] &gt; dist[v] + map[v][j]) { dist[j] = dist[v] + map[v][j]; } } } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { vertex = sc.nextInt(); start = sc.nextInt(); end = sc.nextInt(); edge = sc.nextInt(); for (int i = 1; i &lt;= vertex; i++) { for (int j = 1; j &lt;= vertex; j++) { if (i != j) { map[i][j] = INF; } } } for (int i = 1; i &lt;= edge; i++) { int from = sc.nextInt(); int to = sc.nextInt(); int value = sc.nextInt(); map[from][to] = value; } for (int i = 1; i &lt;= vertex; i++) { dist[i] = INF; visit[i] = false; } dijkstra(); System.out.printf(\"#%d %d\\n\", test_case, dist[end]); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt; #define N 100#define INF 100000 int map[N + 1][N + 1];int visit[N + 1];int dist[N + 1];int vertex;int edge;int start;int end; void dijkstra(void){ int i; int j; int min; int v; dist[start] = 0; for (i = 1; i &lt;= vertex; i++) { min = INF; for (j = 1; j &lt;= vertex; j++) { if (visit[j] == 0 &amp;&amp; min &gt; dist[j]) { min = dist[j]; v = j; } } visit[v] = 1; for (j = 1; j &lt;= vertex; j++) { if (dist[j] &gt; dist[v] + map[v][j]) { dist[j] = dist[v] + map[v][j]; } } }} int main(void){ int test_case; int T; int i; int j; int from; int to; int value; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d %d %d\", &amp;vertex, &amp;start, &amp;end); scanf(\"%d\", &amp;edge); for (i = 1; i &lt;= vertex; i++) { for (j = 1; j &lt;= vertex; j++) { if (i != j) { map[i][j] = INF; } } } for (i = 1; i &lt;= edge; i++) { scanf(\"%d %d %d\", &amp;from, &amp;to, &amp;value); map[from][to] = value; } for (i = 1; i &lt;= vertex; i++) { dist[i] = INF; visit[i] = 0; } printf(\"#%d \", test_case); dijkstra(); printf(\"%d \\n\", dist[end]); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/07/Algorithm-Dijkstra/"},{"title":"ìë£Œêµ¬ì¡° | í (Queue)","text":"Data Structure : Queue(í) íëŠ” ì»´í“¨í„°ì˜ ê¸°ë³¸ì ì¸ ìë£Œ êµ¬ì¡°ì˜ í•œê°€ì§€ë¡œ, ë¨¼ì € ì§‘ì–´ ë„£ì€ ë°ì´í„°ê°€ ë¨¼ì € ë‚˜ì˜¤ëŠ” FIFO (First In First Out)êµ¬ì¡°ë¡œ ì €ì¥í•˜ëŠ” í˜•ì‹ì„ ë§í•©ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ N(2&lt;= N &lt;=100)ê°œì˜ ìˆ˜ë¥¼ ìˆœì„œëŒ€ë¡œ Queueì— ë„£ì€ í›„ í•˜ë‚˜ì”© êº¼ë‚´ í™”ë©´ì— ì¶œë ¥í•˜ì‹œì˜¤. ì…ë ¥ ì¶œë ¥ 2 // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìˆ˜ 5 // ë°ì´í„° í¬ê¸° 1 2 3 4 5 5 5 4 2 3 1 #1 1 2 3 4 5 #2 5 4 2 3 1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Scanner; class Solution { static final int MAX_N = 100; static int front; static int rear; static int queue[] = new int[MAX_N]; static void queueInit() { front = 0; rear = 0; } static boolean queueIsEmpty() { return (front == rear); } static boolean queueIsFull() { if ((rear + 1) % MAX_N == front) { return true; } else { return false; } } static boolean queueEnqueue(int value) { if (queueIsFull()) { System.out.print(\"queue is full!\"); return false; } queue[rear] = value; rear++; if (rear == MAX_N) { rear = 0; } return true; } static Integer queueDequeue() { if (queueIsEmpty()) { System.out.print(\"queue is empty!\"); return null; } Integer value = new Integer(queue[front]); front++; if (front == MAX_N) { front = 0; } return value; } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); queueInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); queueEnqueue(value); } System.out.print(\"#\" + test_case + \" \"); while (!queueIsEmpty()) { Integer value = queueDequeue(); if (value != null) { System.out.print(value.intValue() + \" \"); } } System.out.println(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt; #define MAX_N 100 int front;int rear;int queue[MAX_N]; void queueInit(void){ front = 0; rear = 0;} int queueIsEmpty(void){ return (front == rear);} int queueIsFull(void){ if ((rear + 1) % MAX_N == front) { return 1; } else { return 0; }} int queueEnqueue(int value){ if (queueIsFull()) { printf(\"queue is full!\"); return 0; } queue[rear] = value; rear++; if (rear == MAX_N) { rear = 0; } return 1;} int queueDequeue(int *value){ if (queueIsEmpty()) { printf(\"queue is empty!\"); return 0; } *value = queue[front]; front++; if (front == MAX_N) { front = 0; } return 1;} int main(int argc, char* argv[]){ int T; int N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); queueInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); queueEnqueue(value); printf(\"setValue\"); } printf(\"#%d \", test_case); while (!queueIsEmpty()) { int value; if (queueDequeue(&amp;value) == 1) { printf(\"%d \", value); } } printf(\"\\n\"); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/22/Data-Structure-Queue/"},{"title":"ìë£Œêµ¬ì¡° | ìš°ì„ ìˆœìœ„ í (Priority Queue)","text":"Data Structure : Priority Queue(ìš°ì„ ìˆœìœ„ í) ìš°ì„ ìˆœìœ„ íëŠ” ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§„ ì›ì†ŒëŠ” ë‚®ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§„ ì›ì†Œë³´ë‹¤ ë¨¼ì € ì²˜ë¦¬ë˜ëŠ” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ N(2&lt;= N &lt;=100)ê°œì˜ ìˆ˜ë¥¼ ì‘ì€ ìˆ«ìê°€ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°–ëŠ” Priority Queueì— ì €ì¥í•˜ê³ , ìš°ì„  ìˆœìœ„ê°€ ë†’ì€ ìˆ«ìë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ì¶œë ¥í•˜ì‹œì˜¤.(ì…ë ¥ì—ëŠ” ì˜¤ë¥˜ê°€ ì—†ë‹¤ê³  ê°€ì •) ì…ë ¥ ì¶œë ¥ 2 //í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìˆ˜ 10 //ì…ë ¥ ìˆ˜ 10 49 38 17 56 92 8 1 13 55 //ì…ë ¥ ë°ì´í„° 13 4 22 50 13 5 1 22 35 21 7 99 100 14 #1 1 8 10 13 17 38 49 55 56 92 #2 1 4 5 7 13 14 21 22 22 35 50 99 100 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.Scanner; class Solution { static Scanner sc; static final int MAX_SIZE = 100; static int heap[] = new int[MAX_SIZE]; static int heapSize = 0; static void heapInit() { heapSize = 0; } static void heapPush(int value) { if (heapSize + 1 &gt; MAX_SIZE) { return; } heap[heapSize] = value; int current = heapSize; while (current &gt; 0 &amp;&amp; heap[current] &lt; heap[(current - 1) / 2]) { int temp = heap[(current - 1) / 2]; heap[(current - 1) / 2] = heap[current]; heap[current] = temp; current = (current - 1) / 2; } heapSize = heapSize + 1; } static int heapPop() { if (heapSize &lt;= 0) { return -1; } int value = heap[0]; heapSize = heapSize - 1; heap[0] = heap[heapSize]; int current = 0; while (current &lt; heapSize &amp;&amp; current * 2 + 1 &lt; heapSize) { int child; if (current * 2 + 2 &gt;= heapSize) { child = current * 2 + 1; } else { child = heap[current * 2 + 1] &lt; heap[current * 2 + 2] ? current * 2 + 1 : current * 2 + 2; } if (heap[current] &lt; heap[child]) { break; } int temp = heap[current]; heap[current] = heap[child]; heap[child] = temp; current = child; } return value; } static void heapPrint(int[] heap, int heap_size) { for (int i = 0; i &lt; heap_size; i++) { System.out.print(heap[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); heapInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); heapPush(value); } System.out.print(\"#\" + test_case + \" \"); for (int i = 0; i &lt; N; i++) { System.out.print(heapPop() + \" \"); } System.out.println(); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt; #define MAX_SIZE 100 int heap[MAX_SIZE];int heapSize = 0; void heapInit(void){ heapSize = 0;} int heapPush(int value){ if (heapSize + 1 &gt; MAX_SIZE) { printf(\"queue is full!\"); return 0; } heap[heapSize] = value; int current = heapSize; while (current &gt; 0 &amp;&amp; heap[current] &lt; heap[(current - 1) / 2]) { int temp = heap[(current - 1) / 2]; heap[(current - 1) / 2] = heap[current]; heap[current] = temp; current = (current - 1) / 2; } heapSize = heapSize + 1; return 1;} int heapPop(int *value){ if (heapSize &lt;= 0) { return -1; } *value = heap[0]; heapSize = heapSize - 1; heap[0] = heap[heapSize]; int current = 0; while (current * 2 + 1 &lt; heapSize) { int child; if (current * 2 + 2 == heapSize) { child = current * 2 + 1; } else { child = heap[current * 2 + 1] &lt; heap[current * 2 + 2] ? current * 2 + 1 : current * 2 + 2; } if (heap[current] &lt; heap[child]) { break; } int temp = heap[current]; heap[current] = heap[child]; heap[child] = temp; current = child; } return 1;} int main(int argc, char* argv[]){ int T, N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); heapInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); heapPush(value); } printf(\"#%d \", test_case); for (int i = 0; i &lt; N; i++) { int value; heapPop(&amp;value); printf(\"%d \", value); } printf(\"\\n\"); } return 0;} [ì°¸ê³ ì°¨ë£Œ] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/23/Data-Structure-Priority-Queue/"},{"title":"ìë£Œêµ¬ì¡° | í•´ì‹œ (Hash)","text":"Data Structure : Hash(í•´ì‹œ) í•´ì‹œ í…Œì´ë¸”(Hash table)ì€ í‚¤ë¥¼ ê°’ì— ë§¤í•‘í•  ìˆ˜ ìˆëŠ” êµ¬ì¡°ì¸, ì—°ê´€ ë°°ì—´ ì¶”ê°€ì— ì‚¬ìš©ë˜ëŠ” ìë£Œ êµ¬ì¡°ì…ë‹ˆë‹¤. í•´ì‹œ í…Œì´ë¸”ì€ í•´ì‹œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒ‰ì¸(index, Key)ì„ ë²„í‚·(bucket)ì´ë‚˜ ìŠ¬ë¡¯(slot)ì˜ ë°°ì—´ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ Nê°œì˜ key, dataìŒì„ Hash tableì— ì…ë ¥í•œ í›„, Qê°œì˜ keyë¥¼ ì…ë ¥ ë°›ì•„ keyì— í•´ë‹¹í•˜ëŠ” dataë¥¼ ê° ì¤„ì— ì¶œë ¥í•˜ì‹œì˜¤. (1&lt;=N, Q&lt;=4096) Key : ìµœëŒ€ 64ê°œì˜ ë¬¸ìì—´ Data : ìµœëŒ€ 128ê°œì˜ ë¬¸ìì—´ ì…ë ¥ ì¶œë ¥ 123123123234serf 234sdfdfgdcvb Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Scanner; class Hashtable{ class Hash { String key; String data; } int capacity; Hash tb[]; public Hashtable(int capacity){ this.capacity = capacity; tb = new Hash[capacity]; for (int i = 0; i &lt; capacity; i++){ tb[i] = new Hash(); } } private int hash(String str) { int hash = 5381; for (int i = 0; i &lt; str.length(); i++) { int c = (int)str.charAt(i); hash = ((hash &lt;&lt; 5) + hash) + c; } if (hash &lt; 0) hash *= -1; return hash % capacity; } public String find(String key){ int h = hash(key); int cnt = capacity; while(tb[h].key != null &amp;&amp; (--cnt) != 0) { if (tb[h].key.equals(key)){ return tb[h].data; } h = (h + 1) % capacity; } return null; } boolean add(String key, String data) { int h = hash(key); while(tb[h].key != null) { if (tb[h].key.equals(key)){ return false; } h = (h + 1) % capacity; } tb[h].key = key; tb[h].data = data; return true; }} class Solution{ final static int MAX_TABLE = 4096; public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { Hashtable tb = new Hashtable(MAX_TABLE); int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) { String k = sc.next(); String d = sc.next(); tb.add(k, d); } System.out.printf(\"#%d\\n\", test_case); int Q = sc.nextInt(); for (int i = 0; i &lt; Q; i++) { String k = sc.next(); String d = tb.find(k); if (d != null) { System.out.printf(\"%s\\n\", d); } else { System.out.printf(\"not find\\n\"); } } } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt; #define MAX_KEY 64#define MAX_DATA 128#define MAX_TABLE 4096 typedef struct{ char key[MAX_KEY + 1]; char data[MAX_DATA + 1];}Hash;Hash tb[MAX_TABLE]; unsigned long hash(const char *str){ unsigned long hash = 5381; int c; while (c = *str++) { hash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE; } return hash % MAX_TABLE;} int find(const char *key, char *data){ unsigned long h = hash(key); int cnt = MAX_TABLE; while (tb[h].key[0] != 0 &amp;&amp; cnt--) { if (strcmp(tb[h].key, key) == 0) { strcpy(data, tb[h].data); return 1; } h = (h + 1) % MAX_TABLE; } return 0;} int add(const char *key, char *data){ unsigned long h = hash(key); while (tb[h].key[0] != 0) { if (strcmp(tb[h].key, key) == 0) { return 0; } h = (h + 1) % MAX_TABLE; } strcpy(tb[h].key, key); strcpy(tb[h].data, data); return 1;} int main(int argc, char* argv[]){ int T, N, Q; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { memset(tb, 0, sizeof(tb)); scanf(\"%d\", &amp;N); char k[MAX_KEY + 1]; char d[MAX_DATA + 1]; for (int i = 0; i &lt; N; i++) { scanf(\"%s %s\\n\", &amp;k, &amp;d); add(k, d); } printf(\"#%d\\n\", test_case); scanf(\"%d\", &amp;Q); for (int i = 0; i &lt; Q; i++) { char k[MAX_KEY + 1]; char d[MAX_DATA + 1]; scanf(\"%s\\n\", &amp;k); if (find(k, d)) { printf(\"%s\\n\", d); } else { printf(\"not find\\n\"); } } } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/25/Data-Structure-Hash/"},{"title":"ìë£Œêµ¬ì¡° | ìŠ¤íƒ (Stack)","text":"Data Structure : Stack(ìŠ¤íƒ) ìŠ¤íƒì€ í•œ ìª½ ëì—ì„œë§Œ ìë£Œë¥¼ ë„£ê±°ë‚˜ ëº„ ìˆ˜ ìˆëŠ” ì„ í˜• êµ¬ì¡°(LIFO - Last In First Out)ë¡œ ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” í˜•ì‹ì„ ë§í•©ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ N(2&lt;= N &lt;=100)ê°œì˜ ìˆ˜ë¥¼ ìˆœì„œëŒ€ë¡œ Stackì— ë„£ì€ í›„ í•˜ë‚˜ì”© êº¼ë‚´ í™”ë©´ì— ì¶œë ¥í•˜ì‹œì˜¤. ì…ë ¥ ì¶œë ¥ 2 // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìˆ˜ 5 // ë°ì´í„° í¬ê¸° 1 2 3 4 5 5 5 4 2 3 1 #1 5 4 3 2 1 #2 1 3 2 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.Scanner; class Solution { static final int MAX_N = 100; static int top; static int stack[] = new int[MAX_N]; static void stackInit() { top = 0; } static boolean stackIsEmpty() { return (top == 0); } static boolean stackIsFull() { return (top == MAX_N); } static boolean stackPush(int value) { if (stackIsFull()) { System.out.println(\"stack overflow!\"); return false; } stack[top] = value; top++; return true; } static Integer stackPop() { if (top == 0) { System.out.println(\"stack is empty!\"); return null; } top--; Integer value = new Integer(stack[top]); return value; } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); stackInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); stackPush(value); } System.out.print(\"#\" + test_case + \" \"); while (!stackIsEmpty()) { Integer value = stackPop(); if (value != null) { System.out.print(value.intValue() + \" \"); } } System.out.println(); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt; #define MAX_N 100 int top;int stack[MAX_N]; void stackInit(void){ top = 0;} int stackIsEmpty(void){ return (top == 0);} int stackIsFull(void){ return (top == MAX_N);} int stackPush(int value){ if (stackIsFull()) { printf(\"stack overflow!\"); return 0; } stack[top] = value; top++; return 1;} int stackPop(int *value){ if (top == 0) { printf(\"stack is empty!\"); return 0; } top--; *value = stack[top]; return 1;} int main(int argc, char* argv[]){ int T, N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); stackInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); stackPush(value); } printf(\"#%d \", test_case); while (!stackIsEmpty()) { int value; if (stackPop(&amp;value) == 1) { printf(\"%d \", value); } } printf(\"\\n\"); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/21/Data-Structure-Stack/"},{"title":"ìë£Œêµ¬ì¡° | íŠ¸ë¦¬ (Tree)","text":"Data Structure : Tree(íŠ¸ë¦¬) íŠ¸ë¦¬ êµ¬ì¡°ë€ ê·¸ë˜í”„ì˜ ì¼ì¢…ìœ¼ë¡œ, ì—¬ëŸ¬ ë…¸ë“œê°€ í•œ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¬ ìˆ˜ ì—†ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤. ê°„ë‹¨í•˜ê²ŒëŠ” íšŒë¡œê°€ ì—†ê³ , ì„œë¡œ ë‹¤ë¥¸ ë‘ ë…¸ë“œë¥¼ ì‡ëŠ” ê¸¸ì´ í•˜ë‚˜ë¿ì¸ ê·¸ë˜í”„ë¥¼ íŠ¸ë¦¬(Tree)ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ ì…ë ¥ ê°’ìœ¼ë¡œ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ê³ , êµ¬ì„±ëœ íŠ¸ë¦¬ë¥¼ ì „ìœ„ìˆœíšŒí•˜ê³  ë°©ë¬¸í•œ ë…¸ë“œì˜ ë²ˆí˜¸ë¥¼ ì¶œë ¥í•˜ì‹œì˜¤. ì²« ì¤„ì—ëŠ” ì „ì²´ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ìˆ˜(T), ë‘ ë²ˆì§¸ ì¤„ì—ëŠ” ë…¸ë“œì˜ ì´ ìˆ˜(nodeNum), ê°„ì„ ì˜ ì´ ìˆ˜(edgeNum)ê°€ ì£¼ì–´ì§„ë‹¤. ê·¸ ë‹¤ìŒ ì¤„ì—ëŠ” ê°„ì„ ì´ ë‚˜ì—´ ëœë‹¤. ê°„ì„ ì€ ê·¸ê²ƒì„ ì´ë£¨ëŠ” ë‘ ì •ì ìœ¼ë¡œ í‘œê¸°ëœë‹¤. ê°„ì„ ì€ í•­ìƒ â€œë¶€ëª¨ ìì‹â€ ìˆœì„œë¡œ í‘œê¸° ëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´ â€œ1 2â€ëŠ” ì •ì  1ê³¼ 2ë¥¼ ì‡ëŠ” ê°„ì„ ì„ ì˜ë¯¸í•˜ë©° 1ì´ ë¶€ëª¨ 2ê°€ ìì‹ì„ ì˜ë¯¸í•œë‹¤. ë¶€ëª¨ëŠ” ìµœëŒ€ 2ê°œì˜ ìì‹ ë…¸ë“œë¥¼ ê°–ìœ¼ë©°, ìµœëŒ€ ë…¸ë“œì˜ ê°œìˆ˜ëŠ” 10000ê°œì´ë‹¤. ì…ë ¥ ì¶œë ¥ 2 // Testcase ìˆ˜ 13 12 // N: ë…¸ë“œì˜ ì´ ìˆ˜, E: ê°„ì„ ì˜ ì´ ìˆ˜ 1 2 1 3 2 4 3 5 3 6 4 7 7 12 5 9 5 8 6 11 6 10 11 13 // ê°„ì„  ì •ë³´ (â€œë¶€ëª¨ ìì‹â€ ìˆœì„œ) 10 9 1 2 1 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 #1 1 2 4 7 12 3 5 9 8 6 11 13 10 #2 1 2 3 4 5 6 7 8 9 10 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.Scanner; class Tree { static final int MAX_CHILD_NUM = 2; class TreeNode { int parent; int []child = new int[MAX_CHILD_NUM]; public TreeNode(int parent) { this.parent = parent; for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { child[i] = -1; } } } TreeNode []treenode; int nodeNum; public Tree(int nodeNum) { this.nodeNum = nodeNum; treenode = new TreeNode[nodeNum+1]; for (int i = 0; i &lt;= nodeNum; i++) { treenode[i] = new TreeNode(-1); } } public void addChild(int parent, int child) { int found = -1; for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { if (treenode[parent].child[i] == -1) { found = i; break; } } if (found == -1) return; treenode[parent].child[found] = child; treenode[child].parent = parent; } public int getRoot() { for (int i = 1; i &lt; nodeNum; i++) { if (treenode[i].parent == -1) { return i; } } return -1; } public void preOrder(int root) { System.out.printf(\"%d \", root); for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { int child = treenode[root].child[i]; if (child != -1) { preOrder(child); } } }} class Solution { public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; ++test_case) { int node = sc.nextInt(); int edge = sc.nextInt(); Tree tree = new Tree(node); for (int i = 0; i &lt; edge; i++) { int parent = sc.nextInt(); int child = sc.nextInt(); tree.addChild(parent, child); } int root = tree.getRoot(); System.out.printf(\"#%d \", test_case); tree.preOrder(root); System.out.printf(\"\\n\"); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt; #define MAX_NODE_NUM 10000#define MAX_CHILD_NUM 2 typedef struct{ int parent; int child[MAX_CHILD_NUM];} TreeNode;TreeNode tree[MAX_NODE_NUM];int nodeNum;int edgeNum;int root; void initTree(void) { int i; int j; for (i = 0; i &lt;= nodeNum; i++) { tree[i].parent = -1; for (j = 0; j &lt; MAX_CHILD_NUM; j++) { tree[i].child[j] = -1; } }} void addChild(int parent, int child) { int i; for (i = 0; i &lt; MAX_CHILD_NUM; i++) { if (tree[parent].child[i] == -1) { break; } } tree[parent].child[i] = child; tree[child].parent = parent;} int getRoot(void) { int i; int j; for (i = 1; i &lt;= nodeNum; i++) { if (tree[i].parent == -1) { return i; } } return -1;} void preOrder(int root) { int i; int child; printf(\"%d \", root); for (i = 0; i &lt; MAX_CHILD_NUM; i++) { child = tree[root].child[i]; if (child != -1) { preOrder(child); } }} int main(void){ int test_case; int T; int i; int parent; int child; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; ++test_case) { scanf(\"%d %d\", &amp;nodeNum, &amp;edgeNum); initTree(); for (i = 0; i &lt; edgeNum; i++) { scanf(\"%d %d\", &amp;parent, &amp;child); addChild(parent, child); } root = getRoot(); printf(\"#%d \", test_case); preOrder(root); printf(\"\\n\"); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/26/Data-Structure-Tree/"},{"title":"ìë£Œêµ¬ì¡° | ê·¸ë˜í”„ (Graph)","text":"Data Structure : Graph(ê·¸ë˜í”„) ê·¸ë˜í”„(Graph)ëŠ” ì»´í“¨í„° ì‹œìŠ¤í…œì—ì„œ ì—°ê²°ë˜ì–´ ìˆëŠ” ê°ì²´ê°„ì˜ ê´€ê³„ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆëŠ” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì²«ì§¸ ì¤„ì—ëŠ” Vì™€ Eì˜ ê°¯ìˆ˜, ì •ì ì˜ ì •ë³´ë¥¼ ë¬»ëŠ” ì¿¼ë¦¬ì˜ ê°¯ìˆ˜ê°€ ì£¼ì–´ì§€ê³  ë‘˜ì§¸ ì¤„ë¶€í„° ê°„ì„ ì˜ ì •ë³´(ì—°ê²°ëœ ì •ì ì˜ ë²ˆí˜¸ìŒ)ê°€ ì£¼ì–´ì§„ë‹¤. ê·¸ ë‹¤ìŒ ì¤„ì—ëŠ” ì •ì ì˜ ì¸ì ‘ì •ì ë“¤ì´ ë¬´ì—‡ì¸ì§€ ë¬»ëŠ” ì¿¼ë¦¬ê°€ ì •ì ë²ˆí˜¸ë¡œ ì£¼ì–´ì§„ë‹¤. ì •ì ì˜ ë²ˆí˜¸ëŠ” 0~V-1ê¹Œì§€ ì´ë©°, ê°„ì„ ì •ë³´ëŠ” ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë‚˜ì—´ë˜ì–´ ì£¼ì–´ì§„ë‹¤. ë˜í•œ ì¤‘ë³µ ê°„ì„ ì€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤. ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§€ëŠ” ì¿¼ë¦¬ì˜ ì •ì ì— ì¸ì ‘í•œ ì •ì ë“¤ì„ ê° ì¤„ì— ì¶œë ¥í•˜ë¼. (2&lt;=V&lt;=100, 1&lt;=E&lt;=1000) ì…ë ¥ ì¶œë ¥ 2 6 7 3 // ì •ì ê°¯ìˆ˜, ê°„ì„ ê°¯ìˆ˜ ì¿¼ë¦¬(ì§ˆë¬¸)ê°¯ìˆ˜ 0 1 // ê°„ì„ ì •ë³´ 0 - 1 0 2 0 3 1 2 1 4 3 4 4 5 0 // ì¿¼ë¦¬(ì§ˆë¬¸): ì •ì  ë²ˆí˜¸ 2 4 9 10 3 0 1 0 2 0 6 1 3 1 4 1 7 2 4 4 5 6 7 7 8 0 1 7 #1 1 2 3 // ì •ì 0ì— ì¸ì ‘í•œ ì •ì ë¦¬ìŠ¤íŠ¸ 0 1 // ì •ì 2ì— ì¸ì ‘í•œ ì •ì ë¦¬ìŠ¤íŠ¸ 1 3 5 // ì •ì 4ì— ì¸ì ‘í•œ ì •ì ë¦¬ìŠ¤íŠ¸ #2 1 2 6 0 3 4 7 1 6 8 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.Scanner; class Graph{ class AdjlistNode { int vertex; AdjlistNode next; public AdjlistNode(int v) { vertex = v; next = null; } } class AdjList { int num_members; AdjlistNode head; AdjlistNode tail; public AdjList() { num_members = 0; head = tail = null; } } int num_vertices; AdjList []adjListArr; public Graph(int n) { num_vertices = n; adjListArr = new AdjList[n]; for (int i = 0; i &lt; n; i++) { adjListArr[i] = new AdjList(); } } void addEdge(int src, int dest) { AdjlistNode newNode = new AdjlistNode(dest); if (adjListArr[src].tail != null) { adjListArr[src].tail.next = newNode; adjListArr[src].tail = newNode; } else { adjListArr[src].head = adjListArr[src].tail = newNode; } adjListArr[src].num_members++; newNode = new AdjlistNode(src); if (adjListArr[dest].tail != null) { adjListArr[dest].tail.next = newNode; adjListArr[dest].tail = newNode; } else { adjListArr[dest].head = adjListArr[dest].tail = newNode; } adjListArr[dest].num_members++; } void display(int i) { AdjlistNode adjList = adjListArr[i].head; while (adjList != null) { System.out.printf(\"%d \", adjList.vertex); adjList = adjList.next; } System.out.printf(\"\\n\"); }} class Solution{ public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int V = sc.nextInt(); int E = sc.nextInt(); int Q = sc.nextInt(); Graph graph = new Graph(V); for (int i = 0; i &lt; E; i++) { int sv = sc.nextInt(); int ev = sc.nextInt(); graph.addEdge(sv, ev); } System.out.printf(\"#%d\\n\", test_case); for (int i = 0; i &lt; Q; i++) { int sv = sc.nextInt(); graph.display(sv); } } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;stdio.h&gt;#include &lt;malloc.h&gt; typedef struct adjlistNode{ int vertex; adjlistNode *next;} AdjlistNode; typedef struct{ int num_members; AdjlistNode *head; AdjlistNode *tail;} AdjList; typedef struct{ int num_vertices; AdjList * adjListArr;} Graph; AdjlistNode * createNode(int v){ AdjlistNode * newNode = (AdjlistNode *)malloc(sizeof(AdjlistNode)); newNode-&gt;vertex = v; newNode-&gt;next = NULL; return newNode;} Graph * createGraph(int n){ Graph * graph = (Graph *)malloc(sizeof(Graph)); graph-&gt;num_vertices = n; graph-&gt;adjListArr = (AdjList *)malloc(n * sizeof(AdjList)); for (int i = 0; i &lt; n; i++) { graph-&gt;adjListArr[i].head = graph-&gt;adjListArr[i].tail = NULL; graph-&gt;adjListArr[i].num_members = 0; } return graph;} void destroyGraph(Graph * graph){ if (graph) { if (graph-&gt;adjListArr) { for (int v = 0; v &lt; graph-&gt;num_vertices; v++) { AdjlistNode * adjListPtr = graph-&gt;adjListArr[v].head; while (adjListPtr) { AdjlistNode * tmp = adjListPtr; adjListPtr = adjListPtr-&gt;next; free(tmp); } } free(graph-&gt;adjListArr); } free(graph); }} void addEdge(Graph *graph, int src, int dest){ AdjlistNode * newNode = createNode(dest); if (graph-&gt;adjListArr[src].tail != NULL) { graph-&gt;adjListArr[src].tail-&gt;next = newNode; graph-&gt;adjListArr[src].tail = newNode; } else { graph-&gt;adjListArr[src].head = graph-&gt;adjListArr[src].tail = newNode; } graph-&gt;adjListArr[src].num_members++; newNode = createNode(src); if (graph-&gt;adjListArr[dest].tail != NULL) { graph-&gt;adjListArr[dest].tail-&gt;next = newNode; graph-&gt;adjListArr[dest].tail = newNode; } else { graph-&gt;adjListArr[dest].head = graph-&gt;adjListArr[dest].tail = newNode; } graph-&gt;adjListArr[dest].num_members++;} void displayGraph(Graph * graph, int i){ AdjlistNode * adjListPtr = graph-&gt;adjListArr[i].head; while (adjListPtr) { printf(\"%d \", adjListPtr-&gt;vertex); adjListPtr = adjListPtr-&gt;next; } printf(\"\\n\");} int main(int argc, char* argv[]){ int T, V, E, Q, sv, ev; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d %d %d\", &amp;V, &amp;E, &amp;Q); Graph * graph = createGraph(V); for (int i = 0; i &lt; E; i++) { scanf(\"%d %d\", &amp;sv, &amp;ev); addEdge(graph, sv, ev); } printf(\"#%d\\n\", test_case); for (int i = 0; i &lt; Q; i++) { scanf(\"%d\", &amp;sv); displayGraph(graph, sv); } } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/27/Data-Structure-Graph/"},{"title":"ìë£Œêµ¬ì¡° | ì—°ê²°ë¦¬ìŠ¤íŠ¸ (Linked List)","text":"Data Structure : Linked List(ì—°ê²°ë¦¬ìŠ¤íŠ¸) ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List)ëŠ” ê° ë…¸ë“œê°€ ë°ì´í„°ì™€ í¬ì¸í„°ë¥¼ ê°€ì§€ê³  í•œ ì¤„ë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ë°©ì‹ìœ¼ë¡œ, ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ìë£Œ êµ¬ì¡°ì…ë‹ˆë‹¤. ì˜ˆì‹œë¬¸ì œ ì£¼ì–´ì§„ N(2&lt;= N &lt;=100)ê°œì˜ ìˆ˜ë¥¼ ìˆœì„œëŒ€ë¡œ Linked Listì— ë„£ì€ í›„, 2ê°œì˜ ê°„ê²©ìœ¼ë¡œ í•˜ë‚˜ì”© ë°ì´í„°ë¥¼ ëº„ ë•Œ ë§ˆì§€ë§‰ì— ë‚¨ì•„ ìˆëŠ” ë°ì´í„°ë¥¼ ì¶œë ¥í•˜ì‹œì˜¤. Ex) 1 2 3 4 5 -&gt; 2 3 4 5 -&gt; 2 3 5 -&gt; 2 5 -&gt; 2 ì…ë ¥ ì¶œë ¥ 2 //í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìˆ˜ 5 //ì…ë ¥ ìˆ˜ 1 2 3 4 5 //ì…ë ¥ ë°ì´í„° 6 1 2 3 4 5 6 #1 2 #2 5 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.Scanner; class ListNode { int data; ListNode prev; ListNode next; public ListNode() { data = 0; prev = this; next = this; } public static ListNode appendListNode(ListNode head, int data) { ListNode node = new ListNode(); node.data = data; if (head == null) { head = node; } else { ListNode last = head.prev; last.next = node; head.prev = node; node.prev = last; node.next = head; } return head; } public static ListNode removeListNode(ListNode head, ListNode node) { if (head == head.next) { return null; } else { ListNode prevNode = node.prev; ListNode nextNode = node.next; prevNode.next = nextNode; nextNode.prev = prevNode; return (head == node) ? nextNode : head; } }} class Solution{ public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { ListNode head = null; int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) { int data = sc.nextInt(); head = ListNode.appendListNode(head, data); } ListNode node = head; while(head != head.next) { ListNode nextNode = node.next; head = ListNode.removeListNode(head, node); node = nextNode.next.next; } System.out.printf(\"#%d %d\\n\", test_case, head.data); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt; #define MAX_NODE 100 typedef struct listNode{ int data; struct listNode* prev; struct listNode* next;} ListNode; typedef struct{ int use; ListNode node;} ListNodeHeap; ListNodeHeap heap[MAX_NODE]; void initHeap(void){ int i; for (i = 0; i &lt; MAX_NODE; i++) { heap[i].use = 0; }} void initListNode(ListNode* node){ node-&gt;data = 0; node-&gt;prev = node; node-&gt;next = node;} ListNode* getListNode(void){ int i; for (i = 0; i &lt; MAX_NODE; i++) { if (!heap[i].use) { heap[i].use = 1; initListNode(&amp;heap[i].node); return &amp;heap[i].node; } } return NULL;} void destroyListNode(ListNode* node){ ListNodeHeap* heap_node = (ListNodeHeap*)((int*)node - 1); heap_node-&gt;use = 0;} ListNode* appendListNode(ListNode* list, int data){ ListNode* node = getListNode(); node-&gt;data = data; if (list == NULL) { return node; } else { ListNode* last = list-&gt;prev; last-&gt;next = node; list-&gt;prev = node; node-&gt;prev = last; node-&gt;next = list; return list; }} ListNode* removeListNode(ListNode* list, ListNode* node){ if (list == list-&gt;next) { destroyListNode(node); return NULL; } else { ListNode* prev = node-&gt;prev; ListNode* next = node-&gt;next; prev-&gt;next = next; next-&gt;prev = prev; destroyListNode(node); return (list == node) ? next : list; }} int main(int argc, char* argv[]){ int T, N; setbuf(stdout, NULL); scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; ++test_case) { ListNode* list = NULL; ListNode* node; int i; initHeap(); scanf(\"%d\", &amp;N); for (i = 0; i &lt; N; i++) { int data; scanf(\"%d\", &amp;data); list = appendListNode(list, data); } node = list; while (list != list-&gt;next) { ListNode* nextNode = node-&gt;next; list = removeListNode(list, node); node = nextNode-&gt;next-&gt;next; } printf(\"#%d %d\\n\", test_case, list-&gt;data); } return 0;} [ì°¸ê³ ìë£Œ] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/28/Data-Structure-Linked-List/"},{"title":"Hexo | ì°¬ë¯¸ì˜ ê°œë°œë¸”ë¡œê·¸ - ì‹œì‘ì„ ì—¬ëŠ” ê¸€","text":"ì•ˆë…•í•˜ì„¸ìš”, ì°¬ë¯¸ì˜ ê°œë°œë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì†Œì†Œí•˜ê²Œ IT ë¸”ë¡œê±°ë¡œ í™œë™í•˜ë‹¤ ì ì‹œ ì ‘ì—ˆëŠ”ë°, ê°œë°œê³¼ í•¨ê»˜ ë¸”ë¡œê·¸ë„ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤. Git BlogëŠ” Jekyllë¡œ ì²˜ìŒ ì‹œì‘í–ˆì§€ë§Œ, ìš°ì—¬ê³¡ì ˆ ëì— Hexoë¡œ ë§Œë“  ê°œë°œë¸”ë¡œê·¸ë¡œ ë‹¤ì‹œ ì¸ì‚¬ë“œë¦½ë‹ˆë‹¤. ğŸ”® Git Blogì— ë§¤ë ¥ì„ ëŠë¼ë‹¤ ì €ëŠ” ì‚´ë©´ì„œ ì§€ê¸ˆê¹Œì§€ ì†Œì†Œí•˜ê²Œ ì·¨ë¯¸ë¥¼ ë‚˜ëˆ„ëŠ” ë¸”ë¡œê·¸ë‚˜ IT ë¸”ë¡œê·¸ë¥¼ ìš´ì˜í•´ë³´ì•˜ê³ , â€œê°œë°œâ€ì´ë¼ëŠ” ëª…í™•í•œ ì£¼ì œ í•˜ë‚˜ë¡œ ë¸”ë¡œê·¸ë¥¼ ì‹œì‘í•˜ê¸°ëŠ” ì²˜ìŒì…ë‹ˆë‹¤. ê·¸ë™ì•ˆ ë„¤ì´ë²„ ë¸”ë¡œê·¸ì™€ ê°™ì´ í”Œë«í¼ì—ì„œ ì œê³µëœ ë¸”ë¡œê·¸ë§Œì„ ì‚¬ìš©í•´ì™”ëŠ”ë°, ìš°ì—°íˆ Git Blogë¥¼ ì ‘í•˜ê²Œ ë˜ë©´ì„œ ê°œë°œìë¡œì„œ ì¡ë•í›„ì˜ ê¸¸ì— ë¹ ì§€ê³  ë§ì•˜ìŠµë‹ˆë‹¤. ê·¸ë•Œ ì ‘í–ˆë˜ ë¸”ë¡œê·¸ëŠ” ê¹€ì •í—Œ ë‹˜ì˜ í”„ë¡œê·¸ë˜ë°ìœ¼ë¡œ ì˜ˆìˆ ì„ ê¿ˆê¾¼ë‹¤ ë¼ëŠ” ë¸”ë¡œê·¸ì˜€ëŠ”ë° ì œê²ŒëŠ” ë„ˆë¬´ ì‹ ì„ í•œ ì¶©ê²©ìœ¼ë¡œ ë‹¤ê°€ì™€ì„œ Git Blogë¥¼ ì²˜ìŒ ì ‘í•˜ëŠ” ê³„ê¸°ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤. ë„ˆë¬´ë‚˜ ì œ ì·¨í–¥ìœ¼ë¡œ ì»¤ìŠ¤í…€ì´ ì˜ ë˜ì–´ìˆëŠ” ë¸”ë¡œê·¸ì˜€ìŠµë‹ˆë‹¤. ë§í¬ë¥¼ íƒ€ê³  ë“¤ì–´ê°€ ë³´ì‹œë©´ ì €ì™€ ê°™ì€ ê°ì •ì„ ëŠë¼ì‹¤ì§€ë„ ëª¨ë¥´ê² ìŠµë‹ˆë‹¤. ì €ë„ ì¹´ì¹´ì˜¤ ê¸°ìˆ ë¸”ë¡œê·¸ë‚˜ ìš°ì•„í•œí˜•ì œ ê¸°ìˆ ë¸”ë¡œê·¸ì˜ ê¹”ë”í•œ UIê°€ ë§ˆìŒì— ë“¤ì—ˆëŠ”ë° Git Blogì´ë¼ëŠ” ê²ƒì„ ì•Œê³  ë‚˜ì„œëŠ” ì œê°€ ì›í•˜ëŠ” í…œí”Œë¦¿ê³¼ í´ë” êµ¬ì¡°ë¡œ ë¸”ë¡œê·¸ë¥¼ ì‹œì‘í•˜ê³  ì‹¶ì—ˆìŠµë‹ˆë‹¤. ğŸ“ Hexoë¡œ Devlog ì‹œì‘ Jekyll, Hexo, Gatsby, Hubgo ë“± Github Pageë¥¼ í™œìš©í•˜ì—¬ ë§Œë“¤ ìˆ˜ ìˆëŠ” ë¸”ë¡œê·¸ í”„ë ˆì„ì›Œí¬ì˜ ì¢…ë¥˜ëŠ” ë‹¤ì–‘í•©ë‹ˆë‹¤. Gitìœ¼ë¡œ ê°œë°œë¸”ë¡œê·¸ë‚˜ ê¸°ìˆ ë¸”ë¡œê·¸ë¥¼ ë§Œë“¤ì–´ë´ì•¼ê² ë‹¤ê³  ë‹¤ì§í•œ ë’¤, ì°¸ê³ ë¬¸í—Œì´ ë§ê³  ì‚¬ìš©ìì¸µì´ ë‘êº¼ìš´ Jekyllì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤. ê·¸ë™ì•ˆ ì´ê²ƒì €ê²ƒ ê±´ë“œë ¤ë³´ë©´ì„œ ì»¤ìŠ¤í…€ í•˜ëŠë¼ í•œ ë‹¬ ë™ì•ˆ ì°¸ ë§ì´ í—¤ë§¤ì—ˆìŠµë‹ˆë‹¤. ì œê°€ ë§Œë“¤ê³  ì‹¶ì€ ë¸”ë¡œê·¸ë„ ì°¾ì•„ë³´ì•˜ê³ , ì œì‘ìë¶„ê»˜ ì»¨íƒ ë©”ì¼ë„ ë“œë ¤ë³´ì•˜ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì²˜ìŒ ì ‘í•´ë³¸ Rubyì™€ Liquidë¥¼ íŒŒì•…í•˜ëŠ”ë° ì‹œê°„ì´ ë§ì´ ì†Œëª¨ë˜ì—ˆê³ , ì´ìŠˆ í•´ê²° ê¸°ë¡ì„ ë‚¨ê²¨ë†“ê² ë‹¤ë˜ ì œ ë°”ëŒê³¼ëŠ” ë‹¬ë¦¬ ë¸”ë¡œê·¸ ì œì‘í•˜ëŠ” ê³¼ì •ì´ ì‚°ìœ¼ë¡œ ê°€ëŠ” ë“¯í–ˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë˜ ì¤‘ Javascriptë¥¼ ê³µë¶€í•˜ë©´ì„œ Node.js ê¸°ë°˜ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ Hexoë¡œ ì˜®ê¸°ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. êµ³ì´ ì»¤ìŠ¤í…€ì„ í•˜ì§€ ì•Šì•„ë„ Hexoì—ëŠ” ë” ë©‹ì§„ í…Œë§ˆê°€ ë§ì•˜ìŠµë‹ˆë‹¤. ë‹¤ë§Œ ì´ˆë³´ìì—ê² ì ‘ê·¼í•˜ê¸°ê°€ ë§¤ìš° ì–´ë ¤ìš¸ ê²ƒìœ¼ë¡œ ìƒê°í–ˆìŠµë‹ˆë‹¤. ğŸ§¶ ë‹¹ë©´í–ˆë˜ ë¯¸í•´ê²° ê³¼ì œ : ë‹¤êµ­ì–´ì§€ì› ì‚¬ì´íŠ¸ êµ¬ì¶• ì•„ì‰½ê²Œë„ ë‹¤êµ­ì–´ì§€ì›ì„ í•´ê²°í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. Jekyllì—ëŠ” Jekyll-polyglotì´ë¼ëŠ” í”ŒëŸ¬ê·¸ì¸ì´ ìˆëŠ”ë° Windows í™˜ê²½ì—ë§Œ ë°œìƒí•˜ëŠ” ë²„ê·¸ ë•Œë¬¸ì— ì—ëŸ¬ë¥¼ í•´ê²°í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì–´ë–»ê²Œ í•˜ë©´ í•  ìˆ˜ ìˆì„ì§€ ë”ìš± ê³ ë¯¼í•´ë´ì•¼ í•  ê²ƒ ê°™ìŠµë‹ˆë‹¤. Hexoë¥¼ ì‹œì‘í•˜ë©´ì„œë„ í•œêµ­ì–´ì™€ ì˜ì–´ë¥¼ ì§€ì›í•˜ê³  ì‹¶ì—ˆìœ¼ë‚˜, ì´ëŸ¬ë‹¤ í•œ ê¸€ìë„ ëª» ì ê³  ë¸”ë¡œê·¸ êµ¬ì¶•ì—ë§Œ ë§¤ë‹¬ë¦´ ê²ƒ ê°™ì•„ì„œ ë¨¼ì € í•œêµ­ì–´ë¡œ ì‹œì‘í•´ë³´ë ¤ í•©ë‹ˆë‹¤. ë¶€ë“ì´í•œ ê²½ìš° ì˜ì–´ëŠ” ë‹¤ë¥¸ ê³³ì—ì„œ ì˜ì–´ í¬ìŠ¤íŒ…ì„ í•˜ê²Œ ë  ìˆ˜ë„ ìˆì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤. ì§€ê¸ˆê¹Œì§€ ëˆˆì—¬ê²¨ë´ ë‘” ê³³ì€ Mediumì´ë¼ëŠ” ê³³ì´ì§€ë§Œ í˜„ì¬ ë¸”ë¡œê·¸ì— ë¨¼ì € ì¶©ì‹¤íˆ í•˜ê³ ì í•©ë‹ˆë‹¤. ğŸ“„ ë¸”ë¡œê·¸ ìš´ì˜ ê³„íš ê³ ìƒ ëì— ë‚™ì´ ì˜¨ë‹¤ê³  ë“œë””ì–´ ë¸”ë¡œê·¸ í•˜ë‚˜ ìƒì„±í•˜ì—¬ ìš´ì˜í•˜ê²Œ ë˜ë‹ˆ ë¿Œë“¯í•©ë‹ˆë‹¤. 10ë²ˆë„ ë„˜ê²Œ ìƒì„±í–ˆë‹¤ ì œê±°í–ˆë‹¤ ë°˜ë³µí•˜ë©´ì„œ Hexo ë¸”ë¡œê·¸ë¥¼ êµ¬ì¶•í•˜ëŠ” ë°©ë²•ì„ í•œ ì¤„ í•œ ì¤„ ê¸°ë¡í•´ë‘ì—ˆìŠµë‹ˆë‹¤. Hexo ë¸”ë¡œê·¸ êµ¬ì¶• ë°©ë²•ì— ëŒ€í•´ì„œëŠ” ì°¨ì°¨ í¬ìŠ¤íŠ¸ë¥¼ í•  ìƒê°ì…ë‹ˆë‹¤. ë¬¼ë¡ , ì´ ë¸”ë¡œê·¸ë„ ì•„ì§ ì†ì„ ë³¼ ê³³ë“¤ì´ ë§ìŠµë‹ˆë‹¤. ì‹¤ëª…ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ ë¸”ë¡œê·¸ë¼ ë”ë”ìš± ì‹ ê²½ì„ ì“°ê²Œ ë˜ëŠ” ê²ƒì€ ì–´ì©” ìˆ˜ ì—†ë‚˜ ë´…ë‹ˆë‹¤. ì € ê°™ì€ ì´ˆë³´ìê°€ ì œ ë¸”ë¡œê·¸ë¥¼ ë³¸ë‹¤ë©´ ë„ì›€ì´ ë˜ì—ˆìœ¼ë©´ í•©ë‹ˆë‹¤. ê°œë°œì„ ëª¨ë¥´ëŠ” ì‚¬ëŒì´ ì½ì–´ë„ ì´í•´ë˜ëŠ” ë¸”ë¡œê·¸ë¡œ ë§Œë“¤ê³  ì‹¶ìŠµë‹ˆë‹¤. íŠ¹íˆë‚˜ êµ¬ê¸€ë§í•˜ë‹¤ ë³´ë©´ Git Blogë¥¼ ë§ì´ ì ‘í•´ë³¼ ìˆ˜ ìˆëŠ”ë°, ì›ë¦¬ë¥¼ ì´í•´í•˜ê¸° ì „ê¹Œì§€ëŠ” ì§„ì…ì¥ë²½ì´ ë†’ì€ í¸ì´ë¼ ê·¸ ë²½ì„ ë‚®ì¶”ê³  ì‹¶ë‹¤ëŠ” ìƒê°ë§ˆì € í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. í˜„ì¬ ì•Œê³ ë¦¬ì¦˜ ê³µë¶€ë¥¼ ë¹„ë¡¯í•˜ì—¬ ì´ê²ƒì €ê²ƒ ê³µë¶€ì—, í”„ë¡œì íŠ¸ì—, ì‹ ê²½ì„ ì¨ì•¼ í•  ê²ƒë“¤ì´ ë§ì§€ë§Œ ê·¸ë¦¬ê³  ê¾¸ì¤€íˆ í¬ìŠ¤íŒ…í•´ë³´ê² ìŠµë‹ˆë‹¤. ì»¤ìŠ¤í…€ì€ ì²˜ìŒë¶€í„° ì™„ë²½í•˜ê²Œ í•˜ê¸° í˜ë“¤ê¸°ì— ë¸”ë¡œê·¸ë¥¼ ìš´ì˜í•´ê°€ë©° ì²œì²œíˆ í•´ë³´ë ¤ê³  í•©ë‹ˆë‹¤. ê°œë°œë¸”ë¡œê·¸ë¥¼ ìš´ì˜í•˜ë©´ì„œ ì´ìŠˆí•´ê²° ê³¼ì •ì´ë‚˜ í”„ë¡œì íŠ¸ ì§„í–‰ ê³¼ì •ì„ ê¼¼ê¼¼íˆ ê¸°ë¡í•´ì„œ ì´ê²ƒë„ í¬ìŠ¤íŒ…í•  ìˆ˜ ìˆë„ë¡ í•´ë³´ê² ìŠµë‹ˆë‹¤. êµ¬ê¸€ë§í•˜ë©´ ì›¬ë§Œí•œ ìë£Œë“¤ì„ ì°¾ì„ ìˆ˜ ìˆì§€ë§Œ, ì°¾ì•„ë³´ëŠ” ê²ƒë§Œìœ¼ë¡œëŠ” ê·¸ê²ƒë“¤ì´ ê²°ì½” ì œ ê²ƒì´ ë˜ì§€ëŠ” ëª»í•©ë‹ˆë‹¤. ì§ì ‘ ê¸°ë¡í•˜ê³  ê³µë¶€í•˜ë©° ì œ ê²ƒìœ¼ë¡œ ë§Œë“¤ê¸° ìœ„í•´ ì´ˆì ì„ ë§ì¶”ë ¤ê³  í•©ë‹ˆë‹¤. ì €ëŠ” ì „ë¬¸ê°€ê°€ ë˜ê¸° ìœ„í•´ ë…¸ë ¥í•˜ì§€ë§Œ, ì˜ëª»ëœ ë‚´ìš©ì´ë‚˜ ìˆ˜ì •ì‚¬í•­ì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. Issuesë‚˜ ëŒ“ê¸€ì— ë‚¨ê²¨ì£¼ì‹œë©´ ë¹ ë¥´ê²Œ ë°˜ì˜í•˜ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤. ì˜ ë¶€íƒë“œë¦½ë‹ˆë‹¤!","link":"/Devlog/Hexo/2019/07/15/Hexo-Beginning-of-devlog/"},{"title":"Hexo | í—¥ì†Œ ê°œë°œì ì»¤ë®¤ë‹ˆí‹°ì— ì´ˆëŒ€í•©ë‹ˆë‹¤!","text":"í˜¹ì‹œ Hexo ì‚¬ìš©ìì´ì‹ ê°€ìš”? Git Blog í˜¹ì€ Git Siteë¥¼ ìš´ì˜í•˜ê³  ê³„ì‹œê±°ë‚˜ Hexoì— ê´€ì‹¬ ìˆë‹¤ë©´ ì´ ê¸€ì„ í•œ ë²ˆ ì£¼ëª©í•´ì£¼ì„¸ìš”! ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ Hexoë¥¼ ì‚¬ìš©í•˜ëŠ” ê°œë°œì ì»¤ë®¤ë‹ˆí‹° ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ Github Pageë¥¼ í†µí•´ Git Blogë¥¼ ìš´ì˜í•  ìˆ˜ ìˆëŠ”ë°, Hexo, Jekyll, Gatsby, Hugo ë“± ë§ì€ ë¸”ë¡œê·¸ í”„ë ˆì„ì›Œí¬ê°€ ìˆìŠµë‹ˆë‹¤. ì œê°€ ì–´ë–»ê²Œ Git Blogë¥¼ ì‹œì‘í•˜ê²Œ ë˜ì—ˆëŠ”ì§€ ê¶ê¸ˆí•˜ì‹  ë¶„ë“¤ì€ Hexo | ì°¬ë¯¸ì˜ ê°œë°œë¸”ë¡œê·¸ - ì‹œì‘ì„ ì—¬ëŠ” ê¸€ë¥¼ ì°¸ê³ í•´ì£¼ì„¸ìš”. ì €ëŠ” Jekyllì„ ì‚¬ìš©í•˜ë‹¤ Hexoë¥¼ ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤. Hexoê°€ Jekyllë³´ë‹¤ í•œêµ­ì–´ë¡œ ëœ ì •ë³´ê°€ ì ì€ í¸ì´ë¼ ì˜ì–´ì™€ ì¤‘êµ­ì–´ë¥¼ ì‚¬ìš©í•´ê°€ë©° êµ¬ê¸€ë§í–ˆë˜ ê²½í—˜ì´ ìˆë„¤ìš”. ì € í˜¼ì ì‚½ì§ˆë§Œ í•˜ë‹¤ê°€ ì •ë³´ê³µìœ ë¥¼ ìœ„í•œ ì»¤ë®¤ë‹ˆí‹°ë¥¼ í•˜ë‚˜ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ì´ ê¸€ ë§¨ ì•„ë˜ì— ë§í¬ë¥¼ ê±¸ì–´ë‘ì—ˆê³ , ì •ë³´ê³µìœ ì™€ ì§ˆë¬¸, ìˆ˜ë‹¤ ìœ„ì£¼ë¡œ ì§„í–‰í•˜ê³  ìˆì–´ìš”. ğŸ˜Š í™˜ì˜í•´ìš”! ë„¤í‹°ì¼“ë§Œ ì§€ì¼œì£¼ì‹ ë‹¤ë©´ ììœ ë¡­ê²Œ ì´ìš©í•˜ì‹¤ ìˆ˜ ìˆê³ , ëˆ„êµ¬ë‚˜ í™˜ì˜í•©ë‹ˆë‹¤. ì˜¤í”ˆì¹´í†¡ë°©ì´ë¼ ìµëª…ìœ¼ë¡œ í™œë™í•˜ì‹¤ ìˆ˜ ìˆì–´ìš”. Hexoë¥¼ ì‚¬ìš©í•˜ëŠ” ê°œë°œì ì»¤ë®¤ë‹ˆí‹° Hexoë¡œ ë§Œë“  ê°œë°œë¸”ë¡œê·¸ë‚˜ ê¸°ìˆ ë¸”ë¡œê·¸, ì›¹ì‚¬ì´íŠ¸ ëª¨ë‘ í™˜ì˜í•´ìš”! ê°œë°œì í™˜ì˜! ê°œë°œìê°€ ì•„ë‹ˆì–´ë„ Hexoë¥¼ ì‚¬ìš©í•˜ì‹œëŠ” ë¶„ë“¤ë„ í™˜ì˜! Git Blog ì´ì›ƒí•´ìš”~ ğŸ‘‹ ì˜¤í”ˆì¹´í†¡ë°© ì°¸ì—¬ë°©ë²• í•˜ë‹¨ì˜ ë§í¬ë¡œ ë“¤ì–´ì˜¤ì…”ì„œ ê°„ë‹¨í•œ ìê¸°ì†Œê°œ ë¶€íƒë“œë¦´ê²Œìš”! ì˜¤í”ˆì¹´í†¡ë°© ë§í¬ : â˜… Hexo:í—¥ì†Œ ê°œë°œì ì»¤ë®¤ë‹ˆí‹°","link":"/Devlog/Hexo/2019/11/11/Hexo-Developer-community/"},{"title":"[ì´ìŠˆë“±ë¡] Java ë°°ì—´ì—ì„œ ìµœëŒ€ê°’ ì°¾ê¸° êµ¬ë¬¸ì—ëŸ¬","text":"Error Message: The method max(Collection&lt;? extends T&gt;) in the type Collections is not applicable for the arguments (int[]) ğŸŒ° ì˜¤ë¥˜ë©”ì‹œì§€ 123456// Error MessageException in thread \"main\" java.lang.Error: Unresolved compilation problem: The method max(Collection&lt;? extends T&gt;) in the type Collections is not applicable for the arguments (int[]) at Main.main(Main.java:28) ğŸ’ ë¬¸ì œìƒí™© ë¹„íƒ€ì•Œê³  ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ë‹¤ê°€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. C++ì—ì„œ max_element ì‚¬ìš©í•´ì„œ ë°°ì—´ ìì²´ë¥¼ ìµœëŒ€ê°’ì„ ì°¾ëŠ”ê²Œ ê°€ëŠ¥í•œ ê²ƒ ê°™ì€ë° Javaì—ì„œëŠ” Math.maxë¡œ ë°°ì—´ ë¹„êµê°€ ì•ˆë˜ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤. Java API Documentì—ì„œë„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ğŸ§© ì˜ˆì‹œì½”ë“œ 123// Full CodeëŠ” ì¶”í›„ ì—…ë°ì´íŠ¸ í•˜ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.int maxNum = Collections.max(dp); ğŸ”‘ í•´ê²°ë°©ì•ˆì—¬ê¸°ì„œ 2ê°€ì§€ ê¶ê¸ˆì¦ì„ ê°€ì§€ê³  ì´ìŠˆë“±ë¡ì„ ì§„í–‰í–ˆìœ¼ë©°, í•´ê²°ë˜ëŠ”ëŒ€ë¡œ ê¸€ì„ ì—…ë°ì´íŠ¸í•˜ê² ìŠµë‹ˆë‹¤. ìš°ì„ , Arraysì™€ Collectionsì— ëŒ€í•œ ê¸°ì´ˆê°€ ë¯¸í¡í•˜ë‹¤ê³  ëŠê»´ì„œ ê·¸ ë¶€ë¶„ì— ëŒ€í•´ ê³µë¶€ë¥¼ í•´ë´ì•¼ê² ë„¤ìš”. 1) C++ì—ì„œ max_elementê°€ Javaì—ì„œ Math.maxë‘ ê°™ì€ê°€? 2) Javaë¡œ êµ¬í˜„í•˜ë ¤ë©´ í•˜ë‚˜ì”© max ì¼ì¼ì´ ë¹„êµí•´ì•¼ ë˜ëŠ”ê²ƒì¸ê°€? í•´ê²°ë˜ëŠ”ëŒ€ë¡œ ë³¸ë¬¸ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.","link":"/Devlog/Issues/2019/09/25/Issues-Java-Collection-max/"},{"title":"[ì´ìŠˆí•´ê²°] Java - java.lang.ArrayIndexOutOfBoundsException","text":"Error Message: java.lang.ArrayIndexOutOfBoundsException ğŸŒ° ì˜¤ë¥˜ë©”ì‹œì§€ 1234// Error MessageException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 1 at Main.main(Main.java:12) ğŸ’ ë¬¸ì œìƒí™© ì§€ì› íšŒì‚¬ì˜ ì˜¨ë¼ì¸ ì½”ë”©í…ŒìŠ¤íŠ¸ì— ì‘ì‹œí•˜ë‹¤ê°€ ì—ëŸ¬ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. í•´ë‹¹ ì—ëŸ¬ëŠ” ìµœê·¼ì— ì œê°€ ìì£¼ ì ‘í–ˆë˜ ì—ëŸ¬ì…ë‹ˆë‹¤. ì•„ë˜ ì½”ë“œì˜ ì˜ë„ëŠ” ê°œí–‰ë¬¸ì ë‹¨ìœ„ë¡œ í•œ ë²ˆì— ì…ë ¥ì„ ë°›ì•„ ì²˜ë¦¬í•˜ê³ , ë¬¸ìì—´ê³¼ ìˆ«ìë¥¼ ë”°ë¡œ ë¶„ë¦¬í•˜ë ¤ê³  í–ˆìŠµë‹ˆë‹¤. String[] input = br.readLine().split(&quot;\\\\n&quot;);ì—ì„œ Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsExceptionì—ëŸ¬ê°€ ë°œìƒí–ˆê³ , ì´ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì•Œì•„ë³´ì•˜ìŠµë‹ˆë‹¤. ğŸ§© ì˜ˆì‹œì½”ë“œ 12345678910111213141516// Wrong Code : Errorê°€ ë°œìƒí•œ Full Codeì…ë‹ˆë‹¤.import java.io.*;class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); String[] input = br.readLine().split(\"\\\\n\"); // Error int x = 0; for (int i=0; i&lt;n; i++) { String command = input[i].split(\" \")[0]; x = Integer.parseInt(input[i].split(\" \")[1]); } }} ì˜ˆì‹œ ì…ë ¥ê°’] 12enqueue 1enqueue 2enqueue 2enqueue 1enqueue 2dequeuedequeuedequeuedequeuedequeueenqueue 7dequeue ğŸ”‘ í•´ê²°ë°©ì•ˆ ì˜ˆì‹œ ì…ë ¥ê°’ì„ ë³´ì‹œë©´ dequeueì™€ enqueueê°€ ë²ˆê°ˆì•„ ë‚˜ì˜µë‹ˆë‹¤. String[] inputì—ì„œ í•œ ë²ˆì— ì…ë ¥ë°›ì§€ ì•Šê³ , forë¬¸ì„ ì‚¬ìš©í•˜ì—¬ í•œ ì¤„ì”© ì…ë ¥ë°›ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ì—ëŸ¬ë¥¼ í•´ê²°í–ˆìŠµë‹ˆë‹¤. 1234567891011121314151617// Right Code : Errorë¥¼ í•´ê²°í•œ Full Codeì…ë‹ˆë‹¤.import java.io.*;class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); // String[] input = br.readLine().split(\"\\\\n\"); // Error int x = 0; for (int i=0; i&lt;n; i++) { String input = br.readLine(); // Solving String command = input[i].split(\" \")[0]; x = Integer.parseInt(input[i].split(\" \")[1]); } }} ìœ„ì˜ ì½”ë“œì—ì„œ Errorê°€ ë°œìƒí–ˆë˜ ì…ë ¥ë¬¸ì„ Solving ë¶€ë¶„ìœ¼ë¡œ ë°”ê¿”ì£¼ì–´ ì—ëŸ¬ë¥¼ í•´ê²°í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. í•´ë‹¹ ì´ìŠˆì—ì„œëŠ” ArrayIndexOutOfBoundsException ì—ëŸ¬ê°€ ë‚œ ì´ìœ ê°€ br.readLine()ì— ì´ë¯¸ ê°•ì œê°œí–‰ì´ í¬í•¨ì´ ë˜ì–´ ìˆì–´, ì—†ëŠ” ë¬¸ìì— ì ‘ê·¼í•˜ëŠ” ê²ƒìœ¼ë¡œ ì´í•´í–ˆìŠµë‹ˆë‹¤. ê°œí–‰ë¬¸ì ë‹¨ìœ„ë¡œ ì…ë ¥ì„ ë°›ì„ ê²½ìš°, ìœ„ì˜ ë‚´ìš©ì²˜ëŸ¼ ì…ë ¥ì„ ë°›ëŠ” ê²ƒì´ ë‚«ë‹¤ëŠ” ê²ƒì„ ì•Œê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.","link":"/Devlog/Issues/2019/09/29/Issues-Java-java.lang.ArrayIndexOutOfBoundsException/"},{"title":"[ì´ìŠˆí•´ê²°] Git & Expo-CLI - Input is required, but Expo CLI is in non-interactive mode.","text":"Error Message: Input is required, but Expo CLI is in non-interactive mode. ğŸŒ° ì˜¤ë¥˜ë©”ì‹œì§€ 12[17:52:12] Input is required, but Expo CLI is in non-interactive mode.--template: argument is required in non-interactive mode. Valid choices are: &apos;blank&apos;, &apos;blank (TypeScript)&apos;, &apos;tabs&apos;, &apos;minimal&apos;, &apos;minimal (TypeScript)&apos; or any custom template (name of npm package). ğŸ’ ë¬¸ì œìƒí™© í† ì´í”„ë¡œì íŠ¸ë¡œ ì§„í–‰ì¤‘ì¸ Kawai Todo App with React Nativeë¥¼ ìœ„í•´ expoë¥¼ ì‚¬ìš©í•˜ë ¤ê³  í–ˆìŠµë‹ˆë‹¤. expo-cli ì„¤ì¹˜ë¥¼ í•˜ê¸°ìœ„í•´ Git Bashì—ì„œ npm install expo-cli --global ì…ë ¥ í›„, new projectë¥¼ ìƒì„±í•˜ê¸° ìœ„í•´ expo init Kawai-Todoì„ ì…ë ¥í–ˆë”ë‹ˆ Input is required, but Expo CLI is in non-interactive mode.ë¼ëŠ” ì—ëŸ¬ë©”ì‹œì§€ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ğŸ§© ì˜ˆì‹œì½”ë“œ Wrong Code : Git Bashì—ì„œ ì…ë ¥ í›„ Errorê°€ ë°œìƒí•œ ëª…ë ¹ì–´ì…ë‹ˆë‹¤. 1$ expo init Kawai-Todo ğŸ”‘ í•´ê²°ë°©ì•ˆ 1) Git Bashì—ì„œ ì‚¬ìš©í–ˆë˜ ëª…ë ¹ì–´ë¥¼ cmdì—ì„œ ì…ë ¥í–ˆë”ë‹ˆ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì˜ ë„˜ì–´ê°€ì§‘ë‹ˆë‹¤. Right Code : cmdì—ì„œ Errorë¥¼ í•´ê²°í•œ ëª…ë ¹ì–´ì…ë‹ˆë‹¤. ê¸°ì¡´ ëª…ë ¹ì–´ì™€ ê°™ìŠµë‹ˆë‹¤. 1$ expo init Kawai-Todo 2) í•˜ë‹¨ì˜ ë‚´ìš©ì—ì„œ ë°©í–¥í‚¤ë¥¼ ì´ìš©í•˜ì—¬ ì›í•˜ëŠ” í•­ëª©ì„ ì„ íƒí•˜ê³  ì—”í„°í‚¤ë¥¼ ì…ë ¥í•©ë‹ˆë‹¤. 12345678? Choose a template: (Use arrow keys) ----- Managed workflow -----&gt; blank a minimal app as clean as an empty canvas blank (TypeScript) same as blank but with TypeScript configuration tabs several example screens and tabs using react-navigation ----- Bare workflow ----- minimal bare and minimal, just the essentials to get you started minimal (TypeScript) same as minimal but with TypeScript configuration 3) https://docs.expo.io/versions/latest/workflow/configuration/ ì— ì ‘ì†í•˜ì—¬ ì°¸ê³ í•˜ê³ , ì•± ì„¤ì •ì— ë§ê²Œ ì„¤ì •í•´ì¤ë‹ˆë‹¤. í•˜ë‹¨ì˜ ë©”ì‹œì§€ì—ì„œ ë°©í–¥í‚¤ë¥¼ ì´ìš©í•˜ì—¬ í•´ë‹¹ URL ë¶€ë¶„ ì¤‘ nameìœ¼ë¡œ ì´ë™í•˜ê³ , ì•±ì˜ Home Screenì— ë“¤ì–´ê°ˆ ì´ë¦„ì„ ì…ë ¥í•©ë‹ˆë‹¤. 123456789? Choose a template: expo-template-blank? Please enter a few initial configuration values. Read more: https://docs.expo.io/versions/latest/workflow/configuration/ Â» 50% completed { &quot;expo&quot;: { &quot;name&quot;: &quot;&lt;The name of your app visible on the home screen&gt;&quot;, &quot;slug&quot;: &quot;Kawai-Todo&quot; } } 4) ë‹¤ìŒê³¼ ê°™ì´ 100%ë¡œ ë°”ë€Œì—ˆë‹¤ë©´ ì•± ì„¤ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. 123456789? Choose a template: expo-template-blank? Please enter a few initial configuration values. Read more: https://docs.expo.io/versions/latest/workflow/configuration/ Â» 100% completed { &quot;expo&quot;: { &quot;name&quot;: &quot;Kawai Todo&quot;, &quot;slug&quot;: &quot;Kawai-Todo&quot; } } 5) ì—”í„°í‚¤ë¥¼ ëˆ„ë¥´ë©´ ë‹¤ìŒ ë©”ì‹œì§€ê°€ ë‚˜íƒ€ë‚˜ë©´ì„œ Expo ì„¤ì¹˜ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. 123456âˆš Please enter a few initial configuration values. Read more: https://docs.expo.io/versions/latest/workflow/configuration/ Â· 100% completedExtracting project files...Customizing project...Initialized a git repository.Installing dependencies... 6) ì„¤ì¹˜ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. 12345678910111213141516171819202122232425262728npm WARN deprecated deep-assign@3.0.0: Check out `lodash.merge` or `merge-options` instead.npm WARN deprecated core-js@1.2.7: core-js@&lt;2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.&gt; core-js@2.6.9 postinstall C:\\Users\\kimcm\\Kawai-Todo\\node_modules\\metro-babel-register\\node_modules\\core-js&gt; node scripts/postinstall || echo &quot;ignore&quot;Thank you for using core-js ( https://github.com/zloirock/core-js ) for polyfilling JavaScript standard library!The project needs your help! Please consider supporting of core-js on Open Collective or Patreon:&gt; https://opencollective.com/core-js&gt; https://www.patreon.com/zloirockAlso, the author of core-js ( https://github.com/zloirock ) is looking for a good job -)npm notice created a lockfile as package-lock.json. You should commit this file.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})added 783 packages from 427 contributors and audited 37575 packages in 120.979sfound 11 low severity vulnerabilities run `npm audit fix` to fix them, or `npm audit` for detailsYour project is ready at C:\\Users\\kimcm\\Kawai-TodoTo get started, you can type: cd Kawai-Todo npm start ğŸ€ í›„ê¸° ê°€ë” ì–´ë–¤ ëª…ë ¹ì–´ëŠ” Git Bashì—ì„œ ì‹¤í–‰ì´ ë˜ì§€ ì•Šì„ ë•Œê°€ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ´ ë•ŒëŠ” cmdì—ì„œ í•œ ë²ˆ ì…ë ¥í•´ë³´ë©´ ì˜ ì‘ë™ë˜ëŠ” ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤. Warn ë©”ì‹œì§€ê°€ ìˆ˜ë°˜ë˜ëŠ” ê²½ìš°ê°€ ìˆëŠ”ë°, ì˜¤ë¥˜ë©”ì‹œì§€ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ êµ¬ê¸€ë§í•´ë³´ë©´ Mac OSì—ì„œ ë°œê²¬í•œ ì ì´ ì—†ìŠµë‹ˆë‹¤. Windows í™˜ê²½ì—ì„œ ì‘ì—…í•˜ê³  ìˆê¸° ë•Œë¬¸ì¼ ê²ƒì´ë¼ëŠ” ìƒê°ì´ ë“­ë‹ˆë‹¤. Expo XDEë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ëŠ” ì ì—ì„œ Mac OSë¥¼ ì“°ê³  ì‹¶ë‹¤ëŠ” ìƒê°ì´ ê°•ë ¥íˆ ë“œëŠ” Error Messageì˜€ìŠµë‹ˆë‹¤.","link":"/Devlog/Issues/2019/10/06/Issues-Git-Expo-CLI-is-in-non-interactive-mode/"},{"title":"[ì´ìŠˆë“±ë¡] Git & Hexo - LF will be replaced by CRLF","text":"Error Message: LF will be replaced by CRLF ğŸŒ° ì˜¤ë¥˜ë©”ì‹œì§€ 12345// Error Messagewarning: LF will be replaced by CRLF in About/index.html.The file will have its original line endings in your working directory ğŸ’ ë¬¸ì œìƒí™© Node.js ê¸°ë°˜ ì •ì  ì‚¬ì´íŠ¸ ìƒì„±ê¸°ì¸ Hexoë¥¼ ì‚¬ìš©í•˜ì—¬ ë¸”ë¡œê·¸ë¥¼ ìš´ì˜í•˜ë©´ì„œ ìì£¼ ë³´ì•˜ë˜ ì˜¤ë¥˜ë©”ì‹œì§€ì…ë‹ˆë‹¤. Git Bashì—ì„œ hexo deploy ëª…ë ¹ì–´ë¥¼ ì…ë ¥í•˜ë©´ ëœ¹ë‹ˆë‹¤. êµ¬ë™ì—ëŠ” ë¬¸ì œê°€ ì—†ì–´ì„œ ë¬´ì‹œí•˜ê³  ë„˜ì–´ê°”ì—ˆì§€ë§Œ, í¬ìŠ¤íŠ¸ê°€ ë§ì•„ì§ì— ë”°ë¼ í¬ìŠ¤íŠ¸ ê°œìˆ˜ë§Œí¼ ì—ëŸ¬ë©”ì‹œì§€ë„ í•¨ê»˜ ëŠ˜ì–´ë‚˜ê³  ìˆìŠµë‹ˆë‹¤. í•œ ë²ˆ í•´ê²°í–ˆë˜ ê²ƒ ê°™ì€ë° ì™„ì „íˆ í•´ê²°ì´ ë˜ì§€ ì•Šì•„ ë‹¤ì‹œ ì´ìŠˆ ë“±ë¡í•©ë‹ˆë‹¤. ì§„í–‰ìƒí™©2019.10.06 ì´ìŠˆë“±ë¡ 2019.11.10 Window í™˜ê²½ì—ì„œëŠ” CRLFë¥¼, Linux/Max í™˜ê²½ì—ì„œëŠ” LFê°€ ì ìš©ë©ë‹ˆë‹¤. êµ¬ê¸€ë§ì„ í†µí•´ í•´ê²°í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì°¾ì•˜ìœ¼ë‚˜, ì›ì¸ì€ ë‹¤ë¥¸ ë° ìˆëŠ” ë“¯ í•©ë‹ˆë‹¤. (ì°¸ê³ ì‚¬ì´íŠ¸)","link":"/Devlog/Issues/2019/10/06/Issues-Git-Hexo-LF-will-be-replaced-by-CRLF/"},{"title":"NHN 2019 í•˜ë°˜ê¸° ê¸°ìˆ ë¶€ë¬¸ ì‹ ì…ì‚¬ì› ê³µê°œì±„ìš© ì„¤ëª…íšŒ í›„ê¸°","text":"ì§€ë‚œ 9ì›” 10ì¼, ìºì¹˜ì¹´í˜ í•œì–‘ëŒ€ì—ì„œ \"NHN 2019 í•˜ë°˜ê¸° ê¸°ìˆ ë¶€ë¬¸ ì‹ ì…ì‚¬ì› ê³µê°œì±„ìš© ì„¤ëª…íšŒ\"ê°€ ìˆì—ˆìŠµë‹ˆë‹¤. 1ë¶€ì—ëŠ” ë©˜í† ë§ì„ ì§„í–‰í–ˆê³  2ë¶€ì—ëŠ” ì±„ìš©ì„¤ëª…íšŒë¥¼ ì§„í–‰í–ˆì—ˆëŠ”ë°ìš”, Q&Aì— ë‚˜ì˜¨ ì§ˆì˜ì‘ë‹µ ì¼ë¶€ë¶„ì„ ì •ë¦¬í•´ë³´ì•˜ìŠµë‹ˆë‹¤. 1ë¶€ì—ëŠ” ë¹™ ë‘˜ëŸ¬ì„œ ì•‰ì•„ìˆì—ˆëŠ”ë°ìš”, 1~5ì‹œ ì‚¬ì´ì— 1ì‹œê°„ ê°„ê²©ìœ¼ë¡œ ì§ˆì˜ì‘ë‹µ ì‹œê°„ì´ ìˆì—ˆìŠµë‹ˆë‹¤. ì¸ì‚¬ë‹´ë‹¹ì í•œ ë¶„ê³¼ í˜„ì§ì ë‘ ë¶„ê³¼ í•¨ê»˜ í–ˆìŠµë‹ˆë‹¤. ì„¸ ë¶„ì´ ë²ˆê°ˆì•„ê°€ë©° ì§ˆì˜ì‘ë‹µì„ í•´ì£¼ì…¨ìŠµë‹ˆë‹¤. 1ë¶€ ë©˜í† ë§ : ì§ˆì˜ì‘ë‹µ Q1. ê°œë°œì ì¸ì¬ìƒ A1. ê°œë°œì ì¸ì¬ìƒì´ ì—†ëŠ” ì´ìœ ëŠ” íŠ¹ì •ì§€ì„ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì§€ì›ìì˜ ì„±ê²©ê³¼ íŠ¹ì§•ì„ ë´…ë‹ˆë‹¤. Q2. ì½”ë”©í…ŒìŠ¤íŠ¸ëŠ” ì–´ë–»ê²Œ ì§„í–‰ë˜ëŠ”ì§€? Q2. ì–¸ì–´ëŠ” C, C++, Javaë§Œ ì§€ì›ë˜ë©°, 2ì‹œê°„ë™ì•ˆ ì˜¨ë¼ì¸ìœ¼ë¡œ ì§„í–‰ë©ë‹ˆë‹¤. Q3. Feel the TOAST ë•Œ ë¬´ì—‡ì„ í•˜ëŠ”ì§€? A3. ì˜¤ì „ ë™ì•ˆ 1ë¬¸ì œë¥¼ í’€ê²Œ ë˜ë©° ë¼ì´ë¸Œ ì½”ë”©ìœ¼ë¡œ ì§„í–‰ë©ë‹ˆë‹¤. ì˜¤í›„ì—ëŠ” ê¸°ìˆ ë©´ì ‘ìœ¼ë¡œ ì†ì½”ë”©ì„ í•©ë‹ˆë‹¤. Q4. ì „ì‚°í•™ ê¸°ì´ˆëŠ” ì–´ë–»ê²Œ ê³µë¶€í•´ì•¼ í•˜ëŠ”ì§€? A4. ëŒ€í•™ìƒ ë•Œ ë³´ë˜ ì „ê³µì±…ì´ë‚˜ ìˆ˜ì—…ìš© PPT, ì •ë³´ì²˜ë¦¬ê¸°ì‚¬ ë“± ìì£¼ ì¶œì œë˜ëŠ” ë¬¸ì œ ìœ„ì£¼ë¡œ ê³µë¶€í•˜ë©´ ë©ë‹ˆë‹¤. í•™ìƒ ë•Œ ì¤‘ê°„, ê¸°ë§ê³ ì‚¬ì— ë‚˜ì™”ë˜ ë¬¸ì œë“¤ ìœ„ì£¼ë¡œìš”. Q5. ìê¸°ì†Œê°œì„œ ì“°ëŠ” ê¿€íŒì´ ìˆë‹¤ë©´? A5. ìê¸°ì†Œê°œì„œëŠ” ì„œë¥˜ì „í˜• ë•Œ íƒ€ ê¸°ì—… ì´ë¦„ì„ ì¼ëŠ”ì§€, ì„ì‹œì €ì¥ì„ ìœ„í•´ ë¬´ì˜ë¯¸í•œ ë¬¸ìì—´ì„ ì…ë ¥í•´ë‘ì—ˆëŠ”ì§€ ë“± ë¨¼ì € í™•ì¸í•˜ê³  1ë²ˆë§Œ í™•ì¸í•œë‹¤ê³  í•˜ì‹­ë‹ˆë‹¤. ìµœì¢…ë©´ì ‘ ë•Œ ìê¸°ì†Œê°œì„œì—ì„œ ì§ˆë¬¸ì´ ë‚˜ì˜¬ ìˆ˜ë„, ë‚˜ì˜¤ì§€ ì•Šì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. (ì €ëŠ” íƒ€ ê¸°ì—…ê³¼ëŠ” ë‹¤ë¥´ê²Œ ì¸ì‚¬ë‹´ë‹¹ìë‹˜ê»˜ì„œ ì°¸ ì†”ì§í•˜ë‹¤ëŠ” ì¸ìƒì„ ë°›ì•˜ë„¤ìš”.) Q6. ì–´ë–¤ ê°œë°œí™˜ê²½, ì–´ë–¤ ì–¸ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ”ì§€? A6. íŒ€ë§ˆë‹¤ ë‹¤ë¥´ê² ì§€ë§Œ ì„œë²„ê°œë°œì€ Java, Springì„ ì‚¬ìš©í•˜ê¸°ë„ í•˜ê³  FE ê°œë°œì€ Vueë¥¼ ì‚¬ìš©í•˜ê¸°ë„ í•©ë‹ˆë‹¤. Q7. ì±„ìš©ì¸ì›ì€ ì–´ë–»ê²Œ ë˜ëŠ”ì§€? A7. ì¸ì›ì„ ì •í•´ë‘ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. ì˜¬í•´ëŠ” ì‚¬ì—…í™•ì¥ì´ í™œë°œí•˜ë¯€ë¡œ ì±„ìš© ê·œëª¨ê°€ ì‘ë…„ê³¼ ë¹„ìŠ·í•  ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤. Q8. SWì§€ì‹ í…ŒìŠ¤íŠ¸ëŠ” ì–´ë–¤ í˜•íƒœë¡œ ë¬¸ì œê°€ ì¶œì œë˜ëŠ”ì§€? A8. ê°ê´€ì‹, ë‹¨ë‹µí˜•, ì„œìˆ í˜• ë“± ë‹¤ì–‘í•˜ê²Œ ìˆìœ¼ë©°, ì•„ì£¼ ì ê¹ì´ì§€ë§Œ ìºì¹˜ì—ì„œ ë§Œë“  ì˜ìƒì— ë¬¸ì œê°€ ë‚˜ì˜µë‹ˆë‹¤. 2ë¶€ ì±„ìš©ì„¤ëª…íšŒ ì±„ìš©ì„¤ëª…íšŒëŠ” ìœ„ì˜ ì‚¬ì§„ì…ë‹ˆë‹¤. ìœ„ ì„ ë¬¼ê³¼ ë¹„ì–´íŒŒí‹°ê°€ í•¨ê»˜ ì§„í–‰ë˜ì—ˆìŠµë‹ˆë‹¤. ì „ ì•„ì‰½ê²Œë„ ê°œì¸ì‚¬ì •ìœ¼ë¡œ ë§¥ì£¼ëŠ” ëª» ë§ˆì…¨ì§€ë§Œ ^^; ë‚˜ì¤‘ì— NHNì— ì…ì‚¬í•œë‹¤ë©´ ë…¸íŠ¸ë¶ì— ì”ëœ© ë¶™ì´ê³  ì‹¶ì€ ê·€ì—¬ìš´ ìŠ¤í‹°ì»¤ë“¤ì…ë‹ˆë‹¤. 2019ë…„ 9ì›” 17ì¼ ì˜¤í›„ 2ì‹œê¹Œì§€ ì§€ì›ì„œ ë§ˆê°ì´ë‹ˆ ì–¼ë¥¸ ì§€ì›í•´ì•¼ê² ë„¤ìš”.","link":"/Devlog/Review/2019/09/16/Review-NHN-2019-Technical-Division-Public-Recruitment-Session/"},{"title":"Java | í—·ê°ˆë¦¬ê¸° ì‰¬ìš´ Java ê°œë… #01 ë°°ì—´","text":"í—·ê°ˆë¦¬ê¸° ì‰¬ìš´ Java ê°œë… ì¤‘ ë°°ì—´ì— ëŒ€í•´ ë‹¤ë£¨ì–´, ê°„ëµíˆ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.Java ì–¸ì–´ì— ëŒ€í•œ ê¸°ë³¸ì ì¸ ì§€ì‹ì´ ìˆì–´ì•¼ ì´í•´í•  ìˆ˜ ìˆëŠ” í¬ìŠ¤íŠ¸ì…ë‹ˆë‹¤. 1. 1ì°¨ì› ë°°ì—´ ì„ ì–¸í•˜ëŠ” ë°©ë²• 12345678// ë°©ë²•1int[] arr1 = new int[5];// ë°©ë²•2int[] arr2 = {1, 2, 3, 4, 5};// ë°©ë²•3int[] arr3 = new int[]{1, 2, 3, 4, 5}; 2. ë°°ì—´ í•œ ë²ˆì— ì¶œë ¥í•˜ëŠ” ë°©ë²• 123456789int[] arr = {1, 2, 3, 4, 5};// ë°©ë²•1for (int i=0; i&lt;5; i++) { System.out.println(arr[i]);}// ë°©ë²•2System.out.println(Arrays.toString(arr)); 3. ë°°ì—´ ë³µì‚¬í•˜ëŠ” ë°©ë²• 1234int[] arr = {1, 2, 3, 4, 5};int[] arrCopy = new int[5];System.arraycopy(arr, 0, arrCopy, 0, 5); System.arraycopy(ì›ë³¸ ë°°ì—´, ì‹œì‘ì¸ë±ìŠ¤, ëª©ì ì§€ ë°°ì—´, ì‹œì‘ì¸ë±ìŠ¤, ê°œìˆ˜)ë¥¼ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤. 4. â€˜==â€™ê³¼ â€˜equalsâ€™ì˜ ì°¨ì´ì  1234// new ì—°ì‚°ìë¡œ ê°ì²´ë¥¼ ìƒì„±í•˜ë©´ aì™€ bì˜ ì£¼ì†Œê°’ì´ ë‹¬ë¼ì§‘ë‹ˆë‹¤.String a = new String(\"123\")String b = new String(\"123\") ==ëŠ” ì£¼ì†Œê°’ë§Œì„ ë¹„êµí•˜ì§€ë§Œ, equalsëŠ” ì£¼ì†Œê°’ê³¼ ë¬¸ìì—´ ë‚´ìš©ì„ ë¹„êµí•©ë‹ˆë‹¤. 5. Charì—ì„œ Stringìœ¼ë¡œ ë³€í™˜, Stringì—ì„œ Charë¡œ ë³€í™˜ 12String str = new String(arr); // charì—ì„œ stringìœ¼ë¡œchar[] tmp = str.toCharArray(); // stringì—ì„œ charë¡œ 6. 2ì°¨ì› ë°°ì—´(ë‹¤ì°¨ì› ë°°ì—´) ì„ ì–¸í•˜ëŠ” ë°©ë²• 1int[][] arr = new int[][]{{1,2,3}, {4,5,6}};","link":"/Language/Java/2019/10/03/Java-Easily-confused-Java-concepts-Arrays/"},{"title":"ìš´ì˜ì²´ì œ | #01 ìš´ì˜ì²´ì œ ì†Œê°œ","text":"1. ìš´ì˜ì²´ì œ ì†Œê°œ(1) ê°œìš”ìš´ì˜ì²´ì œë€? ì»´í“¨í„° í•˜ë“œì›¨ì–´ì™€ ì»´í“¨í„° ì‚¬ìš©ì ê°„ì˜ ë§¤ê°œì²´ ì—­í• ì„ í•˜ëŠ” ì‹œìŠ¤í…œ ì†Œí”„íŠ¸ì›¨ì–´ ì»´í“¨í„° ìì›ì„ í†µì œí•˜ê³  í• ë‹¹í•˜ëŠ” ê³µí†µ ê¸°ëŠ¥ì„ ì»´í“¨í„°ì›¨ì–´ ì†Œí”„íŠ¸ì›¨ì–´ í•˜ë‚˜ë¡œ í†µí•©í•œ ê²ƒ ì»¤ë„(Kernel) ìš´ì˜ì²´ì œì˜ í•µì‹¬ìœ¼ë¡œ ë©”ëª¨ë¦¬ì— ìƒì£¼í•˜ë©° ìš´ì˜ì²´ì œì˜ ë‹¤ë¥¸ ë¶€ë¶„ ë˜ëŠ” ì‘ìš© í”„ë¡œê·¸ë¨ ìˆ˜í–‰ì— í•„ìš”í•œ í™˜ê²½ì„ ì„¤ì •í•˜ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ ëª©ì  ì»´í“¨í„° ì‹œìŠ¤í…œì„ í¸ë¦¬í•˜ê²Œ ì´ìš© ì»´í“¨í„° í•˜ë“œì›¨ì–´ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬ ì»´í“¨í„° ìì› ê´€ë¦¬ ì¸¡ë©´ì—ì„œì˜ ìš´ì˜ì²´ì œì˜ ì—­í•  ì¡°ì •ì ìš´ì˜ì²´ì œëŠ” ì‹œìŠ¤í…œì„ ìš´ì˜í•˜ì—¬ ì—¬ëŸ¬ ìš´ì˜ ìš”ì†Œ(í•˜ë“œì›¨ì–´, ì†Œí”„íŠ¸ì›¨ì–´(í”„ë¡œê·¸ë¨), ë°ì´í„°)ë¥¼ ì ì ˆí•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì œì–´ ìì› í• ë‹¹ì ë˜ëŠ” ê´€ë¦¬ì ì»´í“¨í„° ì‹œìŠ¤í…œì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° í•„ìš”í•œ ìì›(í”„ë¡œì„¸ì„œ ì‹œê°„, ë©”ëª¨ë¦¬ ê³µê°„, íŒŒì¼ ì €ì¥ ê³µê°„, ì…ì¶œë ¥ì¥ì¹˜ ë“±)ì„ í• ë‹¹í•˜ëŠ” ì—…ë¬´ ì…ì¶œë ¥ì¥ì¹˜ì™€ ì‚¬ìš©ì í”„ë¡œê·¸ë¨ ì œì–´ ì»´í“¨í„° ì‹œìŠ¤í…œì˜ ë¶€ì ì ˆí•œ ì‚¬ìš©ì´ë‚˜ ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ì‚¬ìš©ì í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰ì˜ ì œì–´ ì…ì¶œë ¥ì¥ì¹˜ë¥¼ ë™ì‘ì‹œí‚¤ê³  í†µì œí•˜ëŠ” ì—­í•  ì»´í“¨í„° ì‹œìŠ¤í…œ êµ¬ì„±ìš”ì†Œì™€ ìš´ì˜ì²´ì œ (2) ìš´ì˜ì²´ì œì˜ ì—­í• ê³¼ ëª©ì ìš´ì˜ì²´ì œì˜ ëª©ì  ìš´ì˜ì²´ì œëŠ” ë‘ ê°€ì§€ ì£¼ìš” ëª©ì ì„ ë‹¬ì„±í•˜ê¸° ìœ„í•´ ë°œì „ í¸ë¦¬ì„± : ì‚¬ìš©ìê°€ í”„ë¡œê·¸ë¨ì„ ê°œë°œí•˜ê³  ì‚¬ìš©í•˜ëŠ” ë° ì¢€ ë” í¸ë¦¬í•œ í™˜ê²½ ì œê³µ íš¨ìœ¨ì„± : ìì›ì„ íš¨ê³¼ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ê° í”„ë¡œê·¸ë¨ì„ ìœ ê¸°ì ìœ¼ë¡œ ê²°í•©í•˜ì—¬ ì‹œìŠ¤í…œ ì „ì²´ ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¤ëŠ” ë°©í–¥ìœ¼ë¡œ ì„¤ê³„ ì²˜ë¦¬ëŠ¥ë ¥ : ì‹œìŠ¤í…œì˜ ìƒì‚°ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” ëŒ€í‘œ ì§€í‘œë¡œ ë‹¨ìœ„ ì‹œê°„ë‹¹ ì²˜ë¦¬í•˜ëŠ” ì‘ì—…ëŸ‰ ì‹ ë¢°ë„ : í•˜ë“œì›¨ì–´(íŒì›¨ì–´), ì†Œí”„íŠ¸ì›¨ì–´ê°€ ì‹¤íŒ¨ ì—†ì´ ì£¼ì–´ì§„ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ëŠ¥ë ¥ ì‘ë‹µì‹œê°„ : ì‚¬ìš©ìê°€ ì‹œìŠ¤í…œì— ì‘ì—…ì„ ì˜ë¢°í•œ í›„ ë°˜ì‘ì„ ì–»ì„ ë•Œê¹Œì§€ì˜ ì‹œê°„ (ì‹œë¶„í•  ë°©ì‹ ì‹œìŠ¤í…œê³¼ ì˜¨ë¼ì¸ ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©í•˜ëŠ” ìš©ì–´, ì¼ê´„ ì²˜ë¦¬ ì‹œìŠ¤í…œì—ì„œëŠ” Turn Around Time) ì‚¬ìš©ê°€ëŠ¥ë„(ê°€ë™ë¥ ) : ì‚¬ìš©ìê°€ ì¼ì • ê¸°ê°„ ë™ì•ˆ ì»´í“¨í„°ë¥¼ ì‹¤ì œë¡œ ì‚¬ìš©í•œ ì‹œê°„(ë¹„ìœ¨) (3) ìš´ì˜ì²´ì œì˜ ìœ í˜•ì¼ê´„ ì²˜ë¦¬ ì‹œìŠ¤í…œ(batch processing system) ìœ íœ´ ìƒíƒœì˜ ì‹œê°„ì„ ì—†ì• ê¸° ìœ„í•˜ì—¬ ì‘ì—… ìˆœì„œì˜ ìë™í™”(automatic job sequencing) ê°œë…ì´ ë„ì… ìƒì£¼ ëª¨ë‹ˆí„°(resident monitor)ë¥¼ ìˆ˜í–‰ ì‘ì—…ì˜ ì¤€ë¹„ ë° ì‹¤í–‰ ìˆœì„œë¥¼ ìë™í™”í•¨ìœ¼ë¡œì¨ ì‹œìŠ¤í…œì˜ ì„±ëŠ¥ì„ ì¦ì§„ ë‹¤ì¤‘ í”„ë¡œê·¸ë˜ë° ì‹œìŠ¤í…œ(multi programming system) ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜ê°€ í•­ìƒ ìˆ˜í–‰ë˜ë„ë¡ í•˜ì—¬ ê·¸ ì´ìš©ë„ë¥¼ ë†’ì´ê¸° ìœ„í•œ ë°©ì•ˆ ì£¼ê¸°ì–µì¥ì¹˜ ë‚´ì— ì—¬ëŸ¬ í”„ë¡œê·¸ë¨ë“¤ì´ ì¡´ì¬í•˜ë„ë¡ ì‹œë¶„í•  ì‹œìŠ¤í…œ(time-sharing system) ì—¬ëŸ¬ ì‚¬ìš©ìë“¤ì´ ì»´í“¨í„° ìì›ì— ëŒ€í•œ ì§§ì€ ì‹œê°„ ë‹¨ìœ„ì˜ ê³µìœ (sharing) ì‚¬ìš©ìëŠ” ëŒ€í™”ì‹(interactive) ë‹¨ë§ì¥ì¹˜ë¥¼ ì´ìš©í•˜ì—¬ ì‹œë¶„í•  ì‹œìŠ¤í…œê³¼ ì¸í„°í˜ì´ìŠ¤ë¥¼ ìˆ˜í–‰ ì‹¤ì‹œê°„ì‹œìŠ¤í…œ(real-time system) ë§¤ìš° ì—„ê²©í•˜ê²Œ ì •ì˜ë˜ì–´ ìˆëŠ” ì‹œê°„ ì œì•½ ë“±ê³¼ ê°™ì€ ì‚¬ê±´ë“¤ì˜ ì œì‹œëœ ìƒí™©ì„ ë¶„ì„ ì‚¬ì „ì— ì •ì˜ëœ ì œì•½ ë‚´ì—ì„œ ìˆ˜í–‰ë˜ì–´ì•¼ í•¨ ë‹¤ì¤‘ ì²˜ë¦¬ ì‹œìŠ¤í…œ(multiprocessing system) ë°€ì°©ëœ ê²°í•©(tightly coupled) ì‹œìŠ¤í…œ í˜¹ì€ ê°•ê²°í•© ì‹œìŠ¤í…œë¼ê³ ë„ í•¨ ë³‘ë ¬ ì‹œìŠ¤í…œ(parallel system)ì´ë¼ê³ ë„ í•¨ ê³µìœ ê¸°ì–µì¥ì¹˜(common memory)ë¥¼ í†µí•˜ì—¬ í•˜ë‚˜ë¡œ ì—°ê²°ëœ ë‹¤ì¤‘ ì²˜ë¦¬ê¸°(multi-processor)ì˜ ì œì–´ ë° ê³µìœ ë¥¼ ìœ„í•œ ì‹œìŠ¤í…œ ê°œì¸ìš© ì»´í“¨í„° ì‹œìŠ¤í…œ ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜ì™€ ì£¼ë³€ì¥ì¹˜ ì´ìš©ë¥ ì„ ìµœëŒ€í™”ì‹œí‚¤ë ¤ëŠ” ë…¸ë ¥ ëŒ€ì‹ ì— í¸ë¦¬ì„±ê³¼ ì‘ë‹µì„±ì„ ë” ì¤‘ìš”ì‹œ í•¨ ë¶„ì‚°ì²˜ë¦¬ ì‹œìŠ¤í…œ(distributed processing system) ëŠìŠ¨í•œ ê²°í•©(loosely coupled) ì‹œìŠ¤í…œì´ë¼ê³ ë„ í•¨. í”„ë¡œì„¸ì„œë“¤ì´ ê¸°ì–µì¥ì¹˜ì™€ í´ëŸ­ì„ ê³µìœ í•˜ì§€ ì•Šìœ¼ë©° ê° í”„ë¡œì„¸ì„œë“¤ì€ ìì‹ ì˜ ì§€ì—­(local) ê¸°ì–µì¥ì¹˜ ë³´ìœ  í”„ë¡œì„¸ì„œë“¤ì€ ê³ ì†ì˜ ë²„ìŠ¤(bus)ë‚˜ ì „í™”ì„ ê³¼ ê°™ì€ ë‹¤ì–‘í•œ í†µì‹  ë¼ì¸ì„ í†µí•´ ì„œë¡œ í†µì‹  ìì›ì„ ê°€ì§€ê³  ìˆëŠ” ì‚¬ì´íŠ¸ëŠ” ì„œë²„(server)ê°€ ë˜ë©°, ë°˜ë©´ ë‹¤ë¥¸ ì‚¬ì´íŠ¸ì—ì„œì˜ í´ë¼ì´ì–¸íŠ¸(client)ë‚˜ ì‚¬ìš©ìëŠ” ê·¸ ìì›ì„ ì‚¬ìš© ë©€í‹°ë¯¸ë””ì–´ ì‹œìŠ¤í…œ(multimedia system) ë‹¤ì–‘í•œ ë¯¸ë””ì–´ë¥¼ ì´ìš©í•˜ì—¬ ë©€í‹°ë¯¸ë””ì–´ ì½˜í…ì¸ ë¥¼ ì œì‘í•˜ê¸° ìœ„í•´ í•„ìš”í•œ í•˜ë“œì›¨ì–´ì™€ ì†Œí”„íŠ¸ì›¨ì–´ë¡œ êµ¬ì„± ë©€í‹°ë¯¸ë””ì–´ ì½˜í…ì¸ ë¥¼ ì œì‘í•˜ê¸° ìœ„í•œ ì €ì‘ë„êµ¬(authoring tool)ê°€ í•„ìš” ì„ë² ë””ë“œ ì‹œìŠ¤í…œ(embedded system) ì •ì˜ ë§ˆì´í¬ë¡œí”„ë¡œì„¸ì„œ ë˜ëŠ” ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ë‚´ì¥í•˜ì—¬ ì‹œìŠ¤í…œ ì œì‘ìê°€ ì˜ë„í•œ ëª‡ ê°€ì§€ í˜¹ì€ íŠ¹ìˆ˜í•œ ê¸°ëŠ¥ë§Œì„ ìˆ˜í–‰í•˜ë„ë¡ ì œì‘ëœ ì‹œìŠ¤í…œ ì„ë² ë””ë“œ ìš´ì˜ì²´ì œì˜ ê°•ì  ì„ë² ë””ë“œ ì‹œìŠ¤í…œê³¼ ê·¸ í•œì •ëœ ìì›ë“¤ì˜ ëŠ¥ë ¥ì— ë§ê²Œ ìµœì í™” (4) ìš´ì˜ì²´ì œì˜ ë°œì „ ê³¼ì •ìš´ì˜ì²´ì œì˜ ë°œì „ ê³¼ì • ìš´ì˜ì²´ì œì™€ ì»´í“¨í„° êµ¬ì¡°ëŠ” ì„œë¡œ ë§ì€ ì˜í–¥ì„ ë¼ì³¤ìœ¼ë©°, ê´€ì°°ì„ í†µí•´ ìš´ì˜ì²´ì œì˜ ê°œë…ì„ ì˜¬ë°”ë¥´ê²Œ ì´í•´í•  ìˆ˜ ìˆë‹¤. í•˜ë“œì›¨ì–´ì™€ ê°™ì´ â€œì„¸ëŒ€â€ë¼ê³  ë¶ˆë¦¬ëŠ” ë°œì „ ë‹¨ê³„ë¥¼ ê±°ì³¤ìœ¼ë©°, ê·¸ ê³¼ì •ì€ ì•„ë˜ì˜ í‘œì™€ ê°™ë‹¤. (5) ìš´ì˜ì²´ì œì— ëŒ€í•œ ê´€ì ìì› ê´€ë¦¬ì ê´€ì  ê° ìì›ì— ëŒ€í•œ ìˆ˜í–‰ ê³¼ì • ìì›ì˜ ìƒíƒœë¥¼ ì¶”ì Â·ì €ì¥ ì–´ë–¤ í”„ë¡œì„¸ìŠ¤ê°€ ì–¸ì œ ì–´ë–¤ ìì›ì„ ì–¼ë§ˆë‚˜ ì‚¬ìš©í•  ê²ƒì¸ì§€ë¥¼ ê²°ì •í•˜ê¸° ìœ„í•œ ì •ì±… ìˆ˜ë¦½ ìì›ì˜ í• ë‹¹ ìì›ì˜ íšŒìˆ˜ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ê¸°ëŠ¥ ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜ì™€ í”„ë¡œì„¸ìŠ¤(process)ì˜ ìƒíƒœë¥¼ ì¶”ì Â·ì €ì¥ í”„ë¡œì„¸ìŠ¤ ìŠ¤ì¼€ì¤„ëŸ¬(process scheduler) ê¸°ì–µì¥ì¹˜ ê´€ë¦¬ ê¸°ëŠ¥ ê¸°ì–µì¥ì¹˜ì˜ ìƒíƒœë¥¼ ì¶”ì Â·ì €ì¥ ì¥ì¹˜(device) ê´€ë¦¬ ê¸°ëŠ¥ ì±„ë„ ë“±ì˜ ì œì–´ì¥ì¹˜ ë° ì…ì¶œë ¥ì¥ì¹˜ì™€ ê°™ì€ ê°ì¢… ì¥ì¹˜ì˜ ìƒíƒœë¥¼ ì¶”ì Â·ì €ì¥ ì…ì¶œë ¥ íŠ¸ë˜í”½ ì œì–´ê¸°(I/O traffic controller) ì…ì¶œë ¥ ìŠ¤ì¼€ì¤„ ë§(I/O scheduling) ì •ë³´ ê´€ë¦¬ ê¸°ëŠ¥ ì •ë³´ì˜ ìœ„ì¹˜, ì‚¬ìš© ì—¬ë¶€ ë° ìƒíƒœ ë“±ì„ ì¶”ì Â·ê´€ë¦¬ íŒŒì¼ì‹œ ìŠ¤í…œ(file system)ì´ë¦¬ê³ ë„ í•¨ í”„ë¡œì„¸ìŠ¤ ê´€ì  í•˜ë‚˜ì˜ ì‘ì—…ì´ ì œì‹œë˜ì–´ ì™„ë£Œë  ë•Œê¹Œì§€ í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ì— ëŒ€í•˜ì—¬ ê·¸ ìƒíƒœë¥¼ ë³€í™˜ì‹œí‚¤ê³  ê´€ë¦¬ [ê·¸ë¦¼1-7] ë‹¤ì¤‘ í”„ë¡œê·¸ë˜ë° ì‹œìŠ¤í…œì—ì„œì˜ ë³µìˆ˜ í”„ë¡œì„¸ìŠ¤ ê³„ì¸µ êµ¬ì¡° ê´€ì  ìì› ê´€ë¦¬ ë£¨í‹´ì´ ì–´ë–»ê²Œ ìˆ˜í–‰ë˜ê³ , ì´ ë£¨í‹´ë“¤ì´ ìƒí˜¸ê°„ì— ì–´ë””ì— ë…¼ë¦¬ì ìœ¼ë¡œ ìœ„ì¹˜í•˜ëŠ”ê°€ ëª¨ë“ˆí™” ëœ ìì› ê´€ë¦¬ [ê·¸ë¦¼1-8] ê³„ì¸µì  ê¸°ê³„ ê°œë…ì˜ êµ¬ì„±ë„ (6) ì…ì¶œë ¥ í”„ë¡œê·¸ë˜ë°ëŒ€ë¶€ë¶„ì˜ ì»´í“¨í„°ì— ìˆì–´ì„œ ì…ì¶œë ¥ì€ ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜ì™€ ë¹„ë™ê¸°ì (asynchronous)ìœ¼ë¡œ ìˆ˜í–‰ì¦‰, ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜ì™€ ì…ì¶œë ¥ì¥ì¹˜ì— ëŒ€í•œ ì‘ë™ì´ ë…ë¦½ì ì´ë©°, ìˆ˜í–‰ìƒì˜ ì‹œê°„ê´€ê³„ ê·œì •ì´ ì—†ì´ ë³‘í–‰ì ìœ¼ë¡œ ìˆ˜í–‰BIOS (basic input/output system) ROMì—ì„œ ì–»ì–´ë‚¸ ì •ë³´ ë¶€íŒ…ëœ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹¤í–‰ì‹œí‚¤ëŠ” ëª…ë ¹ì–´ë“¤ì„ í¬í•¨ ì»´í“¨í„° ì¹©ì— ì €ì¥ëœ ëª…ë ¹ì–´ë“¤ì„ íŒì›¨ì–´(firmware)ë¼ê³  í•¨ BIOSë¥¼ ë›°ì–´ë„˜ëŠ” í™•ì¥ì„± íŒì›¨ì–´ ì¸í„°í˜ì´ìŠ¤(EFI: extensible firmware interface)ê°€ ê°œë°œ ë¶€íŠ¸ ì§„í–‰ê³¼ì •(boot process) ì»´í“¨í„° ê°€ë™ì„ ìœ„í•´ íŒŒì›Œë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ë¶€íŠ¸ ë¡œë”ê°€ ì¤€ë¹„ë™ì‘ì— ë“¤ì–´ê° POST(Power-On Self-Test) ìˆ˜í–‰ ë‹¤ë¥¸ BIOSë“¤ì´ í•´ë‹¹ ì¤€ë¹„ë™ì‘ì— ë“¤ì–´ê°. ìœ ì €ê°€ ì›í•  ê²½ìš° BIOS ì„¸íŒ…ë“¤ì— ì ‘ê·¼ì„ ìœ„í•´ ì¦‰ì‹œ â€˜í‚¤â€™ ì¡°ì‘ ì‹œë„í•¨ ì ê¹ ë™ì•ˆì˜ ë©”ëª¨ë¦¬ í…ŒìŠ¤íŠ¸ê°€ ìˆ˜í–‰ë˜ê³  ì—¬ëŸ¬ íŒŒë¼ë©”íƒ€ë“¤ì´ ì„¸íŠ¸ë¨. í”ŒëŸ¬ê·¸ì™€ í”Œë ˆì´ ë””ë°”ì´ìŠ¤ë“¤ì´ ì¤€ë¹„ë™ì‘ì— ë“¤ì–´ê° DMA(Direct Memory Access)ì±„ë„ì„ ìœ„í•œ ìì›ë“¤ê³¼ IRQ(Interrupt Request)í• ë‹¹ë¨ ë¶€íŠ¸ ë””ë°”ì´ìŠ¤ë“¤ì´ ì •í•´ì§€ê³  ì¤€ë¹„ë™ì‘ì— ë“¤ì–´ê° OSê°€ ì¤€ë¹„ë™ì‘ì— ë“¤ì–´ê° POST (power on self test) ì„±ê³µì ì¸ ë¶€íŒ… ë° ì ì • ìˆ˜í–‰ì˜ í™•ì¸ì„ ìœ„í•´ í•„ìš”í•˜ë“œì›¨ì–´ì— ëŒ€í•´ í–‰í•˜ëŠ” í…ŒìŠ¤íŠ¸ ìˆ˜í–‰í•˜ëŠ” ì¼ ì´ˆê¸°BIOSì˜ ì™„ë²½í•œ ë³´ì „ í™•ì¸ ì£¼ê¸°ì–µì¥ì¹˜ì˜ í• ë‹¹, í™•ì¸ ë° ê·¸ í¬ê¸°(size)ì˜ ê²°ì • ì‹œìŠ¤í…œ ë²„ìŠ¤(buses)ì™€ ì‹œìŠ¤í…œë””ë°”ì´ìŠ¤ì˜ í• ë‹¹ ë° ì‹œì‘ ë‹¤ë¥¸ BIOSë“¤ì˜ ì‹œì‘í—ˆìš© (ë¹„ë””ì˜¤ ë˜ëŠ” ê·¸ë˜í”½ì¹´ë“œ ë“±) ì‚¬ìš©ìì—ê²Œ BIOSì‹œìŠ¤í…œ êµ¬ì„± í˜ì´ì§€ì— ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ê¶Œí•œë¶€ì—¬ ë¶€íŠ¸ ë””ë°”ì´ìŠ¤ í• ë‹¹ ë° ë¶€íŠ¸ íŒŒì¼ì„ ê°€ì§„ ë””ë°”ì´ìŠ¤ ì°¾ê¸° ìš´ì˜ì²´ì œì— ì˜í•´ ìš”êµ¬ë˜ëŠ” ê·¸ ì™¸ ì¤€ë¹„ê´€ë ¨ íƒœìŠ¤í¬ë“¤ì˜ ë§ˆë¬´ë¦¬ ì‘ì—…ì˜ ìˆ˜í–‰ ë²„í¼ë§(buffering) ì…ì¶œë ¥ì¥ì¹˜ì˜ ëŠë¦° ì†ë„ë¥¼ ë³´ì™„í•˜ëŠ” í•œ ê°€ì§€ ë°©ë²• ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜ì™€ ì…ì¶œë ¥ì¥ì¹˜ ê°„ì˜ ì‹œê°„ì  ë¶ˆê· í˜•ì„ ê·¹ë³µ ë¯¸ë¦¬ ì½í˜€ì§„ ë ˆì½”ë“œë“¤ì´ ì¡´ì¬í•˜ëŠ” ê³³ì€ ì£¼ê¸°ì–µì¥ì¹˜ì˜ ì¼ë¶€ [ê·¸ë¦¼1-9] ë²„í¼ë¥¼ ì´ìš©í•œ ì¶œë ¥ì˜ ì˜ˆ ì…ì¶œë ¥ì¥ì¹˜ì˜ ëŠë¦° ì†ë„ë¥¼ ë³´ì™„í•˜ì—¬, ìœ íœ´ì‹œê°„ì´ ì—†ë„ë¡ í”„ë¡œì„¸ì„œì˜ ì—°ì‚° ê³¼ì •ê³¼ í•¨ê»˜ ì–´ë–¤ ì‘ì—…ì˜ ì…ì¶œë ¥ì„ ë™ì‹œì— ìˆ˜í–‰í•˜ëŠ” ê¸°ëŠ¥ ìŠ¤í’€ë§(SPOOLing) ë””ìŠ¤í¬(disk)ë¥¼ ë§¤ìš° í° ë²„í¼ì²˜ëŸ¼ ì‚¬ìš©í•˜ëŠ” ê²ƒ ì±„ë„(channel) ì¶œë ¥ì¥ì¹˜ì™€ ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜ ì‚¬ì´ì— ì…ì¶œë ¥ ì „ë‹´ ì²˜ë¦¬ê¸° [ê·¸ë¦¼1-10] ì…ì¶œë ¥ ì±„ë„ì„ ê°–ëŠ” ì»´í“¨í„° ì‹œìŠ¤í…œ ì„ íƒ ì±„ë„(select channel) ì—¬ëŸ¬ ê°œì˜ ì…ì¶œë ¥ì¥ì¹˜ê°€ ì—°ê²°ë˜ì–´ ìˆë‹¤ í•˜ë”ë¼ë„ í•œ ë²ˆì— ë‹¨ í•˜ë‚˜ì˜ ì…ì¶œë ¥ì¥ì¹˜ë§Œì„ ì„ íƒì ìœ¼ë¡œ ì§€ì› ë¹„êµì  ì „ì†¡ ì†ë„ê°€ ë¹ ë¥¸ ì…ì¶œë ¥ì¥ì¹˜ì¸ ë””ìŠ¤í¬ë‚˜ CD-ROM ë“±ì˜ ì…ì¶œë ¥ì„ ì œì–´ ë©€í‹°í”Œë ‰ì„œ ì±„ë„(multiplexer channel) ë‹¤ìˆ˜ì˜ ì €ì†ë„ ì…ì¶œë ¥ì¥ì¹˜ê°€ ì±„ë„ì˜ ë‹¨ì¼í•œ ë°ì´í„° ê²½ë¡œë¥¼ ê³µìœ í•˜ë©´ì„œ ë°ì´í„°ë¥¼ ì „ì†¡ ì—¬ëŸ¬ ê°œì˜ ì €ì†ë„ ì…ì¶œë ¥ì¥ì¹˜ê°€ ë©€í‹°í”Œë ‰ì„œ ì±„ë„ì— ì—°ê²°ë˜ì–´ ì‹œë¶„í• (timeÂ­sharing) í˜•íƒœë¡œ ì œì–´ í‚¤ë³´ë“œë‚˜ í”„ë¦°í„°ì™€ ê°™ì€ ë¹„êµì  ì „ì†¡ ì†ë„ê°€ ëŠë¦° ì…ì¶œë ¥ì¥ì¹˜ë¥¼ ì œì–´ ì±„ë„ê³¼ ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜ ê°„ì˜ í†µì‹ ì€ ì¼ë°˜ì ìœ¼ë¡œ ì¸í„°ëŸ½íŠ¸(interrupt) [ê·¸ë¦¼1-11] ë‹¤ì–‘í•œ í˜•íƒœì˜ ì±„ë„ ì—°ê²° êµ¬ì¡° ì¸í„°ëŸ½íŠ¸(interrupt) ì‹œìŠ¤í…œì— ì˜ˆê¸°ì¹˜ ì•Šì€ ìƒí™©ì´ ë°œìƒí•˜ì˜€ì„ ë•Œ, ê·¸ê²ƒì„ ìš´ì˜ì²´ì œì— ì•Œë¦¬ê¸° ìœ„í•œ ë©”ì»¤ë‹ˆì¦˜ ì¢…ë¥˜ ì…ì¶œë ¥(I/O) ì¸í„°ëŸ½íŠ¸ ì™¸ë¶€(external) ì¸í„°ëŸ½íŠ¸ SVC(SuperVisor Call) ì¸í„°ëŸ½íŠ¸ ê¸°ê³„ ê²€ì‚¬(machine check) ì¸í„°ëŸ½íŠ¸ í”„ë¡œê·¸ë¨ ì—ëŸ¬(program error) ì¸í„°ëŸ½íŠ¸ ì¬ì‹œì‘(restart) ì¸í„°ëŸ½íŠ¸ êµ¬ì¡° ë° ì²˜ë¦¬ [ê·¸ë¦¼1-12] ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ ê³¼ì • [ê·¸ë¦¼1-13] ì¸í„°ëŸ½íŠ¸ì˜ ì²˜ë¦¬ ê³¼ì • ë° PSW ìœ„ì¹˜","link":"/Computer-Science/Operating-System/2019/08/06/Operating-System-introduce/"},{"title":"ê¹ƒí—ˆë¸Œ ì”ë””ì‹¬ê¸° - 6ê°œì›”ê°„ íšŒê³ ë¡","text":"ì˜¤ëŠ˜ì€ ì²˜ìŒ ì»¤ë°‹í•œ ë‚ ë¡œë¶€í„° 255ì¼ ë˜ëŠ” ë‚ ì´ë©°, 1ì¼ 1ì»¤ë°‹ì„ ì‹¤ì²œí•˜ê¸°ë¡œ ë§ˆìŒë¨¹ì€ ë‚ ë¡œë¶€í„° 247ì¼ì§¸ ë˜ëŠ” ë‚ ì´ë‹¤. ëŒ€ëµ 6ê°œì›” ì •ë„ ë˜ì—ˆìœ¼ë‹ˆ ê¹ƒí—ˆë¸Œ ì”ë””ì‹¬ê¸°ì— ëŒ€í•œ íšŒê³ ë¡ì„ ì ì–´ë³¼ê¹Œ í•œë‹¤. ì—ì„¸ì´ë¥¼ ì‘ì„±í•  ë•ŒëŠ” ë‚´ ìƒê°ê³¼ ëŠë‚Œì„ ì ëŠ” ê¸€ì´ë‹ˆ, í¸í•˜ê²Œ ì ì„ ì˜ˆì •ì´ë‹¤. ì°¸ê³ ë¡œ ë‚˜ëŠ” ë§ë¬¸ì´ íŠ¸ì´ë©´ êµ‰ì¥íˆ ìˆ˜ë‹¤ìŠ¤ëŸ¬ìš´ í¸ì´ë‹¤. ì´ˆë“±í•™êµ 5í•™ë…„ ë•Œë¶€í„° ì¤‘í•™êµ 2í•™ë…„ê¹Œì§€ ë§¤ì¼ í•˜ë£¨ì°¾ê¸°ë¼ëŠ” ì¼ê¸°ë¥¼ ì“°ë©´ì„œ ë§¤ì¼ ìƒˆë¡œìš´ ì—í”¼ì†Œë“œë¡œ ì±„ìš°ëŠ” ë° ë„ê°€ íŠ¼ ì‚¬ëŒì´ë¼ê³  í•  ìˆ˜ ìˆë‹¤. ì—¬í•˜íŠ¼, ê¹ƒí—ˆë¸Œ ì”ë””ì‹¬ê¸° 6ê°œì›”ê°„ íšŒê³ ë¡ì„ ì ê¸° ì „, ê¹ƒí—ˆë¸Œë¥¼ ì‹œì‘í•˜ê²Œ ëœ ê³„ê¸°ì— ê´€í•´ ì–˜ê¸°í•´ë³´ê² ë‹¤. ğŸ– ê¹ƒí—ˆë¸Œ(Github)ë¥¼ ì²˜ìŒ ì‹œì‘í•˜ê²Œ ëœ ê³„ê¸° ê¹ƒí—ˆë¸Œë¥¼ ì²˜ìŒ ì•Œê²Œ ëœ ê²ƒì€ ëŒ€í•™êµ 3í•™ë…„ ë•Œì˜€ë‹¤. ê·¸ë•ŒëŠ” ì•ˆë“œë¡œì´ë“œ(Android) GUI ì„¤ê³„ë¥¼ í•˜ë©´ì„œ ë””ìì¸ì  ìš”ì†Œì— ë©”ë§ë¼ ìˆëŠ” ìƒíƒœì˜€ë‹¤. ê·¸ë„ ê·¸ëŸ´ ê²ƒì´, ë„ˆë¬´ í‰ì´í•œ ê¸°ë³¸ ë””ìì¸ì€ ë‚˜ì˜ ì„±í–¥ê³¼ ë§ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ì¢€ ë” í‰ë©´ì ì´ë©´ì„œ ë©‹ì§„ ë²„íŠ¼ ì´ë¯¸ì§€ë¥¼ ì°¾ê¸°ë¥¼ ì›í–ˆë‹¤. í•¨ê»˜ í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í–ˆë˜ ë™ì•„ë¦¬ ì„ ë°° ì¤‘ í•œ ë¶„ì´ ê¹ƒí—ˆë¸Œë¥¼ ì•Œë ¤ì£¼ì—ˆë‹¤. ê·¸ë•ŒëŠ” READMEë¥¼ ì½ì„ ì¤„ ëª°ë¼ì„œ ë§ì´ í—¤ë§¤ì—ˆê³  â€˜ì•„ ì´ëŸ° ê²Œ ìˆêµ¬ë‚˜~â€™í•˜ê³  ë„˜ê²¨ë²„ë ¸ë‹¤. ì§€ê¸ˆ ìƒê°í•´ë³´ë©´ ë„ˆë¬´ ì•„ì‰¬ì›€ì´ í¬ë‹¤. ê·¸ë•Œ ë°”ë¡œ ê¹ƒí—ˆë¸Œë¥¼ ì‹œì‘í–ˆë‹¤ë©´ ë‚´ RepositoryëŠ” ì¢€ ë” í’ì„±í•´ì ¸ ìˆì—ˆì„ ê²ƒì´ë‹¤! ê·¸ë¦¬ê³  ëª‡ ë…„ ë’¤, êµ­ë¹„ ì§€ì› êµìœ¡ì„ ë°›ìœ¼ë©´ì„œ í˜‘ì—…ë„êµ¬ë¡œì¨ ê¹ƒí—ˆë¸Œë¥¼ ë‹¤ì‹œ ì ‘í•˜ê²Œ ë˜ì—ˆë‹¤. ê·¸ë•Œ ì²˜ìŒ ê³„ì •ì„ ìƒì„±í–ˆê³ , íŒ€ì›ë“¤ì„ ì˜ êµ¬ìŠ¬ë ¤ì„œ íŒ€ í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í•  ë•Œ ê¹ƒí—ˆë¸Œë¥¼ ì´ìš©í•˜ë ¤ê³  ë¬´ì§„ì¥ ë…¸ë ¥í–ˆë‹¤. ëŒ€ë¶€ë¶„ì´ ê¹ƒí—ˆë¸Œë¥¼ ì´ìš©í•´ë³´ì§€ ì•Šì•„ ë§ì´ ì–´ë ¤ì›Œí–ˆìœ¼ë¯€ë¡œ ê³µë¶€ê°€ ë§ì´ í•„ìš”í–ˆë‹¤. Git Bashë¥¼ ì²˜ìŒë¶€í„° ì‚¬ìš©í•˜ê¸° ì–´ë ¤ìš°ë‹ˆ íšŒì‚¬ì—ì„œ ë§ì´ ì‚¬ìš©í•œë‹¤ê³  ìµíˆ ë“¤ì€ Source Treeë¥¼ ë‚´ë ¤ë°›ì•˜ë‹¤. Commit, Push, Pull, Branch ë“± ì˜¨í†µ ëª¨ë¥´ëŠ” ë‹¨ì–´íˆ¬ì„±ì´ì˜€ì§€ë§Œ êµ¬ê¸€ë§ì„ í•´ê°€ë©° ìš©ì–´ë¥¼ ìµí˜”ë‹¤. ìš©ì–´ë“¤ì— ìµìˆ™í•´ì§ˆ ë•Œì¯¤ Commit í›„ Master Branchì— Pushí•˜ë©´ Contribution ì˜ì—­ì— ì´ˆë¡ìƒ‰ì´ ì—¬ëŸ¬ ê°€ì§€ ìƒ‰ê¹”ë¡œ ì¹ í•´ì§€ëŠ” ê²ƒì´ ì¸ìƒì ì´ì—ˆë‹¤. Branchë¡œ Mergeí•˜ê³  Rebaseí•˜ê³ â€¦. Branch ê´€ë ¨ ê°œë…ì´ ì–´ë ¤ì›Œì„œ ì¤‘ê°„ì— í¬ê¸°í•˜ê³  ì‹¶ì„ ë•Œë§ˆë‹¤ ë‚˜ì—ê²Œ ê°•í•œ ë™ê¸°ë¶€ì—¬ê°€ ëœ ê¸€ì´ ìˆì—ˆëŠ”ë°, ì´ìˆ˜ì§„ ë‹˜ì´ ì‘ì„±í•˜ì‹  ê¹ƒí—ˆë¸Œë¡œ ì·¨ì—…í•˜ê¸° ë¼ëŠ” ê¸€ì´ì—ˆë‹¤. ì´ ê¸€ì„ ì½ìœ¼ë©° ê¹ƒí—ˆë¸Œë¥¼ ì´ìš©í•˜ëŠ” ë°©ì‹ì„ ë°”ê¾¸ì–´ë‚˜ê°”ê³  ëˆ„êµ°ê°€ì˜ 1ë…„ê°„ Contribution ì´ë¯¸ì§€ê°€ ì²¨ë¶€ë¼ ìˆì—ˆëŠ”ë°, í•œ í•´ë¥¼ ì´ˆë¡ ë“¤íŒìœ¼ë¡œ ê½‰ ì±„ìš´ ì´ë¯¸ì§€ì— ë§ˆìŒì„ ë¹¼ì•—ê²¼ë‹¤ê³ ë‚˜ í• ê¹Œ. 1ì¼ 1ì»¤ë°‹ì„ í•´ì•¼ê² ë‹¤ê³  ë‹¤ì§í•˜ê²Œ ë˜ì—ˆë‹¤. ğŸ‘§ 1ì¼ 1ì»¤ë°‹ì„ í•˜ë©° ì½”ë•(Co-duck)ì´ ë˜ë‹¤ 1ì¼ 1ì»¤ë°‹ì„ ì§€ì†í•´ì„œ í•  ìˆ˜ ìˆë„ë¡ ë™ê¸°ë¶€ì—¬ê°€ ëœ ìš”ì†ŒëŠ” 2ê°€ì§€ê°€ ìˆë‹¤. í•˜ë‚˜ëŠ” ê¹ƒí—ˆë¸Œ ì”ë””ì •ì›ì‚¬ë¼ëŠ” ì»¤ë®¤ë‹ˆí‹°ì˜€ê³ , ë‹¤ë¥¸ í•˜ë‚˜ëŠ” ì½”ë• ì´ë¼ëŠ” ì‚¬ì´íŠ¸ì˜€ë‹¤. ì§€ê¸ˆì€ ì”ë””ì •ì›ì‚¬ ì»¤ë®¤ë‹ˆí‹°ì—ì„œ í™œë™í•˜ê³  ìˆì§€ëŠ” ì•Šì§€ë§Œ, ì˜¨Â·ì˜¤í”„ë¼ì¸ì—ì„œ ë‹¤ì–‘í•œ ë¶„ì•¼ì˜ ê°œë°œìë“¤ì„ ì•Œê²Œ ë˜ë©´ì„œ 1ì¼ 1ì»¤ë°‹ ê¹ƒí—ˆë¸Œ ê´€ë¦¬ë¥¼ í†µí•´ ë‚˜ì˜ ê°œë°œì‹¤ë ¥ì„ í–¥ìƒí•˜ê³ ì í•˜ëŠ” ë° ê°•í•œ ìê·¹ì´ ë˜ì—ˆë‹¤. ì½”ë• ì´ë¼ëŠ” ì‚¬ì´íŠ¸ì— ëŒ€í•´ ì†Œê°œí•´ì•¼ í•  ê²ƒì´ ë§ì€ë°, ê°„ëµíˆ ì†Œê°œí•˜ìë©´ ê¶Œìš©ê·¼ ë‹˜ì˜ ê°œì¸ ì‚¬ì´ë“œ í”„ë¡œì íŠ¸ ì¤‘ í•˜ë‚˜ë¡œ ê¹ƒí—ˆë¸Œ í™œë™ ì¥ë ¤ë¥¼ ìœ„í•œ ì‚¬ì´íŠ¸ì´ë‹¤. ë‹¤ì–‘í•œ ì§€í‘œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìˆœìœ„ì‹œìŠ¤í…œì„ êµ¬ì¶•í•´ë†”ì„œ íƒ€ ì‚¬ìš©ìì™€ ì•Œê²Œ ëª¨ë¥´ê²Œ ê²½ìŸì‹¬ë¦¬ë¥¼ ìê·¹í•œë‹¤. êµ­ë¹„ ì§€ì› êµìœ¡ì„ ë°›ìœ¼ë©´ì„œ ê·¸ë‚ ê·¸ë‚  ë°°ìš´ ë‚´ìš©ì„ ì»¤ë°‹í•˜ê³¤ í–ˆëŠ”ë°, ì”ë””ì •ì›ì‚¬ì—ì„œ ì•Œê²Œ ëœ ì§€ì¸ë“¤ê³¼ ì—ì¹˜ë½ë’¤ì¹˜ë½ ìˆœìœ„ ê²½ìŸí•˜ëŠ” ê²ƒì´ ì°¸ìœ¼ë¡œ ì¬ë°Œì—ˆë‹¤. ì‹œê°ì ìœ¼ë¡œ í•˜ë£¨ í• ë‹¹ëŸ‰ì„ ì–¼ë§ˆë‚˜ í–ˆëŠ”ì§€ ëˆˆì— ë³´ì´ê²Œ ë˜ëŠ” ì…ˆì´ë‹ˆ, ì´ˆë°˜ì—ëŠ” ì½”ë“œë¥¼ í•œ ì¤„ì´ë¼ë„ ë” ì ìœ¼ë ¤ê³  ë¨¸ë¦¬ ì“´ ì ë„ ë§ì•˜ë˜ ê²ƒ ê°™ë‹¤. ì•„ì‰¬ìš´ ì ì´ë¼ë©´ êµ­ë¹„ ì§€ì› êµìœ¡ì„ ìˆ˜ë£Œí•˜ê³  ë³¸ê²©ì ìœ¼ë¡œ ì·¨ì—… ì „ì„ ì— ë›°ì–´ë“¤ì–´ êµ¬ì§í™œë™ì„ í•˜ë‹¤ ë³´ë‹ˆ 1ì¼ 1ì»¤ë°‹ì„ ë†“ì¹œ ë‚ ë„ ëª‡ ë²ˆ ìˆì—ˆë‹¤. ê·¸ë¦¬ê³  ì˜ë¬¸ë„ ëª¨ë¥´ê²Œ ë»¥ ëš«ë ¤ë²„ë¦° ë‚ ì´ ë”± í•˜ë‚˜ ìˆì§€ë§Œ ì§€ê¸ˆë„ ì›ì¸ì„ ì°¾ì§€ ëª»í–ˆë‹¤. ê·¸ë™ì•ˆ ë‚˜ë§Œì˜ 100ì¼ í”„ë¡œì íŠ¸ ëª©í‘œë¥¼ ì„¸ìš°ê³ , 1ì¼ 1ì»¤ë°‹ì„ ì œëŒ€ë¡œ ì‹¤ì²œí–ˆë‹¤. 2019ë…„ ì‹œì¦Œ 06, 07, 08ì—ì„œ 3ë²ˆ ì—°ì† TOP 10 ìˆœìœ„ê¶Œì— ë“¤ì—ˆë‹¤. ê°ê° 6ë“±, 5ë“±, 5ë“± ì´ë ‡ê²Œ ë°›ì•˜ë‹¤. ìˆœìœ„ê¶Œì— ìˆë‹¤ ë³´ë‹ˆ ì•Œê²Œ ëª¨ë¥´ê²Œ ëª¨ë¥´ëŠ” ë¶„ë“¤í•œí…Œ íŒ”ë¡œì›Œë„ ë°›ì•˜ë˜ ì ë„ ìˆì—ˆë‹¤. ğŸ“Œ ê¹ƒí—ˆë¸Œ ì”ë””ì‹¬ê¸°ì— ëŒ€í•œ ì¼ì¹¨ ê°œë°œìë¼ë©´ ëˆ„êµ¬ë‚˜ Gitì´ë‚˜ Github í˜¹ì€ Gitlabì„ í•˜ê²Œ ë  ê²ƒì´ë‹¤. ê·¸ë˜ì„œ ë” ì¤‘ìš”í•˜ê²Œ ìƒê°í–ˆê³ , ê·¸ë§Œí¼ ê¹ƒí—ˆë¸Œ ì”ë””ì‹¬ê¸°ê°€ ë‚˜ì˜ ê°œë°œê²½í—˜ ì¤‘ í° ë¶€ë¶„ì„ ì°¨ì§€í•˜ê³  ìˆë‹¤. ìê¸°ì†Œê°œì„œì— ê¹ƒí—ˆë¸Œì™€ ì½”ë• ì–˜ê¸°ë¥¼ ì“´ ì ì´ ìˆì—ˆëŠ”ë°, í•œ ë²ˆì€ ë©´ì ‘ì„ ë³´ë©´ì„œ VCSì— ëŒ€í•œ ì§ˆë¬¸ì´ ë‚˜ì™”ë‹¤. ë‹¹ì—°íˆ Git Bashë„ ì‚¬ìš©í•´ë´¤ê³  Githubë„ ì‚¬ìš©í•´ë´¤ë”ë‹ˆ ì¼ì¼ì»¤ë°‹ì— ëŒ€í•´ ì‹ ë‚˜ê²Œ ì–˜ê¸°í–ˆëŠ”ë° ë‚´ ê¹ƒí—ˆë¸Œì˜ ì”ë””ë¥¼ ë³¸ ë©´ì ‘ê´€ë‹˜ì´ íˆ­ ë‚´ë±‰ì€ ë§ì´ ì¸ìƒì ì´ì—ˆë‹¤. â€œì¼ì¼ì»¤ë°‹í•´ì„œ ì¶•êµ¬ì¥ ë§Œë“œì‹¤ ê±°ì—ìš”?â€ ê·¸ë•ŒëŠ” ëˆˆë¹›ì„ ë°˜ì§ì´ë©° ì›ƒìœ¼ë©´ì„œ, â€œë„¤! ê·¸ê²ƒë„ ì¢‹ê² ë„¤ìš”!â€ë¼ê³  ë§í–ˆë˜ ê²ƒ ê°™ë‹¤. ë‚´ ì£¼ë³€ ê°œë°œì ì§€ì¸ë“¤ì€ ê¹ƒí—ˆë¸Œ ì¼ì¼ì»¤ë°‹ì´ ë¬´ìŠ¨ ì˜ë¯¸ê°€ ìˆëŠëƒê³  í‰ê°€ì ˆí•˜í•˜ê¸°ë„ í•œë‹¤. â€œê·¸ê±° ë³„ë¡œ ì•ˆ ì¤‘ìš”í•´. ë¬´ì—‡ì„ ì»¤ë°‹í•˜ëŠ”ê²Œ ì¤‘ìš”í•œ ê±°ì§€â€ë¼ê³  ë§í•˜ê³¤ í•œë‹¤. ë§¤ì¼ ì˜ë¯¸ ìˆëŠ” ì»¤ë°‹ì„ í–ˆëŠëƒê³  ëˆ„êµ°ê°€ ë¬»ëŠ”ë‹¤ë©´, ì†”ì§í•˜ê²Œ ê¹Œë†“ê³  ë§í•´ì„œ ë¶€ë„ëŸ½ì§€ë§Œ ë‚˜ëŠ” ì•„ë‹ˆì—ˆë‹¤ê³  ëª‡ ë²ˆì€ í…ìŠ¤íŠ¸ë§Œ ê³ ì¹œ ì  ìˆë‹¤ê³  ëŒ€ë‹µí•œ ì ì´ ìˆë‹¤. í•œì°½ ì˜ë¯¸ ìˆëŠ” ì»¤ë°‹ì„ í•  ë•ŒëŠ” í”„ë¡œì íŠ¸ ë‹¨ìœ„ë¡œ ì˜¬ë ¸ëŠ”ë°, READMEì˜ ì¤‘ìš”ì„±ì„ ì•Œê²Œ ëœ í›„ì—ëŠ” ì¢€ ë” ì‹ ê²½ ì“°ê²Œ ëœ ê²ƒ ê°™ë‹¤. ğŸ“š ì¼ì¼ì»¤ë°‹ì— ëŒ€í•œ ì² í•™ ë‚˜ì˜ ê¹ƒí—ˆë¸Œ ì”ë””ì‹¬ê¸°ì— ëŒ€í•œ ì² í•™ ì¤‘ í•˜ë‚˜ëŠ” ì¼ì¼ì»¤ë°‹ìœ¼ë¡œì¨ ì–´ë–¤ ì§€ì‹ì„ ì°¨ê³¡ì°¨ê³¡ ìŒ“ì•„ë‚˜ê°€ê±°ë‚˜, ë‚´ê°€ ì–´ë–¤ ê²ƒì„ ì§„í–‰í•˜ê³  ìˆê³ , ê·¸ê²ƒì— ëª°ì…í•˜ê³  ìˆë‹¤ëŠ” ê²ƒì„ ì‹œê°ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆì–´ì„œ ìœ ìš©í•˜ë‹¤ëŠ” ê²ƒì´ë‹¤. ì§ˆì´ ë†’ì€ í”„ë¡œê·¸ë¨ì„ ë§¤ì¼ ë§¤ì¼ ë§Œë“¤ì–´ë‚´ë©´ ì¢‹ê² ì§€ë§Œ ìƒê°ë³´ë‹¤ ì‰½ì§€ ì•Šë‹¤. ë‚˜ëŠ” ì²œì¬ê°€ ì•„ë‹ˆë¯€ë¡œ ê°œë°œì„ í•˜ë‹¤ ë³´ë©´ ë²„ê·¸ë„ ìƒê¸°ê³  ì´ìŠˆë„ ìƒê¸´ë‹¤. ë‚´ê°€ ì§€ê¸ˆ ì§‘ì¤‘í•˜ê³  ìˆëŠ” ê²ƒì´ ì–´ë–¤ ê²ƒì¸ì§€ ì´ë ¥ì´ ë‚¨ëŠ”ë‹¤ëŠ” ê²ƒ, ê¸°ë¡ë˜ê³  ìˆë‹¤ëŠ” ê²ƒì— í° ê°€ì¹˜ë¥¼ ë‘ê³  ìˆë‹¤. ê·¸ë¦¬ê³  ê²Œì„ì„ í•˜ëŠ” ê²ƒë§Œí¼ ì”ë””ë¥¼ ì‹¬ëŠ” ì¼ì´ ìƒê°ë³´ë‹¤ ì¬ë¯¸ìˆë‹¤. ì´ë™ìš± ë‹˜ì˜ ì¼ì¼ì»¤ë°‹ì˜ íš¨ìš©ì„±ì´ë€ ê¸€ì„ ì½ì€ ì ì´ ìˆëŠ”ë°, ë§¤ìš° ê³µê°ì´ ê°€ëŠ” ê¸€ê·€ê°€ ìˆë‹¤. ì¼ì¼ì»¤ë°‹ì€ ì™„ë²½í•˜ì§„ ì•Šì§€ë§Œ ì´ë¥¼ ë³´ì—¬ì¤€ë‹¤. ë‚˜í•œí…Œ ì¼ì¼ì»¤ë°‹ì€ ê³µë¶€/ìê¸°ê°œë°œì´ ì•„ë‹ˆë¼ ê·¸ëƒ¥ ê²Œì„ì¼ ë¿ì´ë‹¤.ë ˆë²¨ì—…í•˜ë“¯ì´, ê²Œì„ ì† í™”íë¥¼ ëª¨ìœ¼ë“¯ì´ ì°¨ê³¡ì°¨ê³¡ ìŒ“ì´ëŠ” ê²Œ ë³´ì´ëŠ” RPG ê²Œì„ ê°™ì€ ê±°ë¼ ì •ë§ ì¤‘ë…ì„± ìˆë‹¤. 1ì¼ 1ì»¤ë°‹ìœ¼ë¡œ ìœ ëª…í•œ ì´ë™ìš± ë‹˜ì€ ì–´ë–»ê²Œ 1ë…„ì„ ë‹¤ ì±„ìš°ì…¨ëŠ”ì§€â€¦. ì •ë§ ëŒ€ë‹¨í•˜ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤. ê·¸ë¦¬ê³  ë”ìš± ì •ì§„í•˜ì—¬ ë³¸ë°›ì•„ì•¼ê² ë‹¤. ğŸ“† ì•ìœ¼ë¡œì˜ ê³„íš ì‚¬ì‹¤ ê¹ƒí—ˆë¸ŒëŠ” í˜¼ì ì‚¬ìš©í•˜ëŠ” ê²ƒë³´ë‹¤ í˜‘ì—…ë„êµ¬ë¡œì¨ ì‚¬ìš©í•˜ëŠ” ë° ë” ì˜ë¯¸ê°€ ìˆë‹¤ê³  ìƒê°í•œë‹¤. ê·¸ë¦¬ê³  ë‚´ê°€ ì˜¬ë ¤ë†“ì€ ì½”ë“œ ì¤‘ ì´ë ‡ê²Œ ë°”ê¿”ì•¼ì§€ ì €ë ‡ê²Œ ë°”ê¿”ì•¼ì§€ ì‹¶ì€ ë¶€ë¶„ë“¤ì´ ì¢…ì¢… ë³´ì—¬ì„œ, ì–´ë–»ê²Œ í•˜ë©´ ë¬´ê²°ì  ì½”ë“œë¡œ ì‘ì„±í•  ìˆ˜ ìˆì„ì§€ ê³„ì† ê³ ë¯¼í•˜ê²Œ ë  ê²ƒ ê°™ë‹¤. ì§„í–‰ ì¤‘ì¸ ì¥ê¸° í”„ë¡œì íŠ¸ì™€ í† ì´ í”„ë¡œì íŠ¸, ê³„íší•˜ê³  ìˆëŠ” í”„ë¡œì íŠ¸ë¥¼ ê¹ƒí—ˆë¸Œì— ì»¤ë°‹í•  ìˆ˜ ìˆë„ë¡ í•  ì˜ˆì •ì´ë‹¤.","link":"/Devlog/Essay/2019/11/06/Essay-Github-Grass-Plantation-A-Memoir-for-6-Month/"}],"tags":[{"name":"Review","slug":"Review","link":"/tags/Review/"},{"name":"NHN","slug":"NHN","link":"/tags/NHN/"},{"name":"Public Recruitment Session","slug":"Public-Recruitment-Session","link":"/tags/Public-Recruitment-Session/"},{"name":"ì±„ìš©ì„¤ëª…íšŒ","slug":"ì±„ìš©ì„¤ëª…íšŒ","link":"/tags/ì±„ìš©ì„¤ëª…íšŒ/"},{"name":"Job Hunter","slug":"Job-Hunter","link":"/tags/Job-Hunter/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Issues","slug":"Issues","link":"/tags/Issues/"},{"name":"ì–¸ì–´","slug":"ì–¸ì–´","link":"/tags/ì–¸ì–´/"},{"name":"ì´ìŠˆí•´ê²°/ì´ìŠˆë“±ë¡","slug":"ì´ìŠˆí•´ê²°-ì´ìŠˆë“±ë¡","link":"/tags/ì´ìŠˆí•´ê²°-ì´ìŠˆë“±ë¡/"},{"name":"ì—ëŸ¬ë©”ì‹œì§€","slug":"ì—ëŸ¬ë©”ì‹œì§€","link":"/tags/ì—ëŸ¬ë©”ì‹œì§€/"},{"name":"Computer Science","slug":"Computer-Science","link":"/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Insertion Sort","slug":"Insertion-Sort","link":"/tags/Insertion-Sort/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"Quick Sort","slug":"Quick-Sort","link":"/tags/Quick-Sort/"},{"name":"Counting Sort","slug":"Counting-Sort","link":"/tags/Counting-Sort/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"DFS Searching","slug":"DFS-Searching","link":"/tags/DFS-Searching/"},{"name":"BFS Searching","slug":"BFS-Searching","link":"/tags/BFS-Searching/"},{"name":"Parametric Search","slug":"Parametric-Search","link":"/tags/Parametric-Search/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"Permutation","slug":"Permutation","link":"/tags/Permutation/"},{"name":"Combination","slug":"Combination","link":"/tags/Combination/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Priority Queue","slug":"Priority-Queue","link":"/tags/Priority-Queue/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"Devlog","slug":"Devlog","link":"/tags/Devlog/"},{"name":"Jekyll","slug":"Jekyll","link":"/tags/Jekyll/"},{"name":"ì°¬ë¯¸ì˜ ê°œë°œë¸”ë¡œê·¸","slug":"ì°¬ë¯¸ì˜-ê°œë°œë¸”ë¡œê·¸","link":"/tags/ì°¬ë¯¸ì˜-ê°œë°œë¸”ë¡œê·¸/"},{"name":"ê°œë°œë¸”ë¡œê·¸","slug":"ê°œë°œë¸”ë¡œê·¸","link":"/tags/ê°œë°œë¸”ë¡œê·¸/"},{"name":"ì»¤ë®¤ë‹ˆí‹°","slug":"ì»¤ë®¤ë‹ˆí‹°","link":"/tags/ì»¤ë®¤ë‹ˆí‹°/"},{"name":"ì´ìŠˆë“±ë¡","slug":"ì´ìŠˆë“±ë¡","link":"/tags/ì´ìŠˆë“±ë¡/"},{"name":"Collections","slug":"Collections","link":"/tags/Collections/"},{"name":"Arrays","slug":"Arrays","link":"/tags/Arrays/"},{"name":"ì´ìŠˆí•´ê²°","slug":"ì´ìŠˆí•´ê²°","link":"/tags/ì´ìŠˆí•´ê²°/"},{"name":"java.lang.ArrayIndexOutOfBoundsException","slug":"java-lang-ArrayIndexOutOfBoundsException","link":"/tags/java-lang-ArrayIndexOutOfBoundsException/"},{"name":"Git Bash","slug":"Git-Bash","link":"/tags/Git-Bash/"},{"name":"Expo-CLI","slug":"Expo-CLI","link":"/tags/Expo-CLI/"},{"name":"Expo CLI is in non-interactive mode","slug":"Expo-CLI-is-in-non-interactive-mode","link":"/tags/Expo-CLI-is-in-non-interactive-mode/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"LF will be replaced by CRLF","slug":"LF-will-be-replaced-by-CRLF","link":"/tags/LF-will-be-replaced-by-CRLF/"},{"name":"Language","slug":"Language","link":"/tags/Language/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"Essay","slug":"Essay","link":"/tags/Essay/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"ì”ë””","slug":"ì”ë””","link":"/tags/ì”ë””/"},{"name":"Contribution","slug":"Contribution","link":"/tags/Contribution/"},{"name":"ì¼ì¼ì»¤ë°‹","slug":"ì¼ì¼ì»¤ë°‹","link":"/tags/ì¼ì¼ì»¤ë°‹/"}],"categories":[{"name":"Devlog","slug":"Devlog","link":"/categories/Devlog/"},{"name":"Issues","slug":"Issues","link":"/categories/Issues/"},{"name":"Review","slug":"Devlog/Review","link":"/categories/Devlog/Review/"},{"name":"Hexo","slug":"Devlog/Hexo","link":"/categories/Devlog/Hexo/"},{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","link":"/categories/Computer-Science/Algorithm/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","link":"/categories/Computer-Science/Data-Structure/"},{"name":"Issues","slug":"Devlog/Issues","link":"/categories/Devlog/Issues/"},{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Java","slug":"Language/Java","link":"/categories/Language/Java/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","link":"/categories/Computer-Science/Operating-System/"},{"name":"Essay","slug":"Devlog/Essay","link":"/categories/Devlog/Essay/"}]}